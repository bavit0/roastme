<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• RoastMe with Fire Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        html {
            overflow-y: hidden;
        }
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }
        .custom-scrollbar-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 12px;
            height: 100vh;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .custom-scrollbar-container.visible {
            opacity: 1;
        }
        .custom-scrollbar-track {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
        }
        .custom-scrollbar-thumb {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, #ffa502);
            border-radius: 6px;
            cursor: pointer;
            min-height: 20px;
            opacity: 0.7;
            transition: opacity 0.2s, background 0.3s;
        }
        .custom-scrollbar-thumb:hover,
        .custom-scrollbar-thumb.dragging {
            opacity: 1;
            background: linear-gradient(45deg, #ff5252, #ffb74d);
        }
        .content-wrapper {
            margin-right: 12px;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
        }
        .content-wrapper::-webkit-scrollbar {
            display: none;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
        }
        .logo {
            font-size: 3.5rem;
            margin-bottom: 15px;
            color: #ff6b6b;
            text-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .logo:hover {
            transform: scale(1.1) rotate(5deg);
            text-shadow: 0 0 25px rgba(255, 107, 107, 0.8);
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ffa502, #ff6b6b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-size: 300% 300%;
            animation: gradient 3s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .subtitle {
            font-size: 1.2rem;
            color: #a0a0c0;
            max-width: 600px;
            margin: 0 auto 20px;
            line-height: 1.6;
        }
        .emoji-showcase {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .emoji-showcase span {
            font-size: 2rem;
            animation: bounce 2s infinite;
        }
        .emoji-showcase span:nth-child(2) { animation-delay: 0.2s; }
        .emoji-showcase span:nth-child(3) { animation-delay: 0.4s; }
        .emoji-showcase span:nth-child(4) { animation-delay: 0.6s; }
        .emoji-showcase span:nth-child(5) { animation-delay: 0.8s; }
        /* Style for the bug emoji if it's added */
        .emoji-showcase span.bug-emoji { animation-delay: 1.0s; }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        .input-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        #username {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        #username:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }
        #username::placeholder {
            color: #6c757d;
        }
        #roast-btn {
            padding: 15px 30px;
            background: linear-gradient(45deg, #ff6b6b, #ffa502);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        #roast-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }
        #roast-btn:active {
            transform: translateY(0);
        }
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.12);
        }
        .stat-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffa502;
        }
        .stat-label {
            color: #a0a0c0;
            font-size: 0.9rem;
        }
        .repo-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .repo-title {
            font-weight: bold;
            color: #ffa502;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }
        .repo-url {
            color: #4ecdc4;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .repo-url:hover {
            text-decoration: underline;
        }
        .commit-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            scrollbar-width: none;
        }
        .commit-list::-webkit-scrollbar {
            display: none;
        }
        .commit-item {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .commit-item:last-child {
            border-bottom: none;
        }
        .commit-message {
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 5px;
            word-break: break-word;
        }
        .commit-date {
            font-size: 0.8rem;
            color: #a0a0c0;
        }
        .faq-section, .about-section, .hall-of-fame-section, .compiler-section, .token-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        .faq-section h2, .about-section h2, .hall-of-fame-section h2, .compiler-section h2, .token-section h2 {
            color: #4ecdc4;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        .faq-item {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .faq-question {
            font-weight: bold;
            color: #ffa502;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        .faq-answer {
            color: #bebece;
            line-height: 1.6;
        }
        .about-content, .compiler-content {
            line-height: 1.7;
            color: #e0e0ff;
        }
        .about-content p, .compiler-content p {
            margin-bottom: 15px;
        }
        .hall-of-fame-content {
            line-height: 1.7;
            color: #e0e0ff;
        }
        .hall-of-fame-content p {
            margin-bottom: 15px;
        }
        .roast-examples {
            background: rgba(255, 107, 107, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #ff6b6b;
        }
        .roast-example {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
        }
        .roast-example:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .example-username {
            color: #ffa502;
            font-weight: bold;
        }
        .compiler-trigger {
            position: relative;
            display: inline-block;
            cursor: pointer;
            color: #6c757d;
        }
        .compiler-trigger:hover {
            color: #c0c0e0;
        }
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .nav-btn {
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #4ecdc4;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        .nav-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            transform: translateY(-2px);
        }
        .nav-btn.active {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ecdc4;
        }
        .disclaimer {
            text-align: center;
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 40px;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .progress-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }
        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffa502);
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-text {
            text-align: center;
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #ffa502;
            font-style: italic;
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #ffa502;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .toggle-results-btn {
            display: none;
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #4ecdc4;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin-top: 20px;
        }
        .toggle-results-btn:hover {
            background: rgba(78, 205, 196, 0.2);
        }
        .results-section {
            display: none;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }
        .modal-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #ffa502;
            text-align: center;
        }
        .modal-text {
            font-size: 1.3rem;
            line-height: 1.6;
            margin-bottom: 25px;
            color: #e0e0ff;
            text-align: justify;
        }
        .modal-text a {
            color: #4ecdc4;
            text-decoration: none;
        }
        .modal-text a:hover {
            text-decoration: underline;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .modal-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .modal-btn-wide {
            padding: 15px 30px;
            width: 100%;
        }
        .primary-btn {
            background: linear-gradient(45deg, #ff6b6b, #ffa502);
            color: white;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }
        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #4ecdc4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .secondary-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            transform: translateY(-2px);
        }
        .token-input-container {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
        }
        .token-input-group {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        #token-input {
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        #token-input:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        .token-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        .token-valid {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        .token-invalid {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        #show-all-btn {
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        #scroll-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 107, 107, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 9999;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        #scroll-to-top:hover {
            background: rgba(255, 107, 107, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }
        #scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .scroll-to-top-icon {
            width: 24px;
            height: 24px;
            fill: white;
        }
        .forbidden-modal .modal-title {
            font-size: 2rem;
            color: #ff6b6b;
        }
        .forbidden-modal .modal-text {
            font-size: 1.2rem;
            text-align: center;
        }
        .forbidden-modal .modal-btn {
            padding: 10px 20px;
        }
        .robot-modal {
            z-index: 10000;
        }
        .robot-modal .modal-content {
            text-align: center;
            padding: 50px 30px;
        }
        .robot-emoji {
            font-size: 6rem;
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .typewriter-text {
            font-size: 1.4rem;
            margin-bottom: 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .typewriter-text::after {
            content: "|";
            animation: blink 1s infinite;
            margin-left: 5px;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        .robot-modal .modal-buttons {
            margin-top: 20px;
        }
        .robot-modal .modal-btn {
            padding: 12px 25px;
            margin: 0 10px;
        }
        .token-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .token-info a {
            color: #4ecdc4;
            text-decoration: none;
        }
        .token-info a:hover {
            text-decoration: underline;
        }
        .delete-token-btn {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        .delete-token-btn:hover {
            background: rgba(231, 76, 60, 0.3);
            transform: translateY(-2px);
        }
        /* Styles for the new Super Error Modal */
        .super-error-modal .modal-title {
            color: #ffcc00; /* Different color for error */
        }
        .super-error-modal .modal-text {
            text-align: center;
        }
        .super-error-modal .modal-btn {
            padding: 10px 20px;
        }
        
        /* Fire Effect Styles */
        .fire-container {
            position: fixed;
            bottom: -350px;
            left: 0;
            width: 100%;
            height: 350px;
            pointer-events: none;
            z-index: -1; /* Behind all content */
            transition: bottom 1s ease-out;
        }

        .fire-container.active {
            bottom: -50px;
        }

        .fire-container.fade-out {
            bottom: -350px;
            transition: bottom 1s ease-in;
        }

        .fire {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at bottom, rgba(255, 100, 0, 0.8) 0%, rgba(255, 0, 0, 0.4) 40%, transparent 70%);
            filter: blur(30px);
            animation: fire-glow 1.2s infinite alternate;
        }

        .fire-particles {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.3s ease 0.5s;
        }

        .fire-container.active .fire-particles {
            opacity: 1;
        }

        .particle {
            position: absolute;
            background: rgba(255, 100, 0, 0.8);
            border-radius: 50%;
            bottom: 0;
            animation: rise 3s infinite;
        }

        @keyframes fire-glow {
            0% {
                opacity: 0.7;
                transform: scale(1);
            }
            100% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        @keyframes rise {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-350px) translateX(30px);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            h1 {
                font-size: 2.2rem;
            }
            .stats-container {
                grid-template-columns: 1fr 1fr;
            }
            .nav-buttons {
                flex-direction: column;
                align-items: center;
            }
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            .token-input-group {
                flex-direction: column;
            }
            #scroll-to-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }
            .scroll-to-top-icon {
                width: 20px;
                height: 20px;
            }
        }
        @media (max-width: 480px) {
            .stats-container {
                grid-template-columns: 1fr;
            }
            .emoji-showcase {
                gap: 8px;
            }
            .emoji-showcase span {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Fire Effect Container -->
    <div class="fire-container" id="fireContainer">
        <div class="fire"></div>
        <div class="fire-particles" id="fireParticles"></div>
    </div>
    
    <div class="custom-scrollbar-container" id="custom-scrollbar">
        <div class="custom-scrollbar-track">
            <div class="custom-scrollbar-thumb" id="scrollbar-thumb"></div>
        </div>
    </div>
    <div class="content-wrapper" id="content-wrapper">
        <div class="container">
            <header>
                <div class="logo" id="hall-of-fame-btn">üî•</div>
                <h1>ROASTME</h1>
                <p class="subtitle">Drop a GitHub username and we'll dig through their commit graveyard, questionable code, and emoji crimes.</p>
                <div class="emoji-showcase" id="emoji-showcase">
                    <span>üçñ</span>
                    <span>‚ô®Ô∏è</span>
                    <span>ü•©</span>
                    <span>ü•ì</span>
                    <span>üç≥</span>
                     <!-- Bug emoji will be inserted here if petted -->
                </div>
            </header>
            <section class="input-section">
                <div class="input-group">
                    <input type="text" id="username" placeholder="Enter GitHub username..." autocomplete="off">
                    <button id="roast-btn">ROAST THEM!</button>
                </div>
                <div class="progress-container" id="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="progress-text" id="progress-text">Initializing analysis...</div>
                    <div class="loading" id="loading-indicator">
                        <div class="spinner"></div>
                        <span>Scanning repositories...</span>
                    </div>
                </div>
                <button class="toggle-results-btn" id="toggle-results-btn">Show Analysis Results</button>
            </section>
            <div class="nav-buttons">
                <button class="nav-btn" id="token-btn">TOKEN</button>
                <button class="nav-btn" id="faq-btn">FAQ</button>
                <button class="nav-btn" id="about-btn">ABOUT</button>
            </div>
            <section class="token-section" id="token-section">
                <h2>üîë TOKEN MANAGEMENT</h2>
                <div class="token-input-container">
                    <p>Enter your GitHub personal access token:</p>
                    <div class="token-input-group">
                        <input type="password" id="token-input" placeholder="Enter your token here...">
                        <button class="modal-btn primary-btn" id="save-token-btn">Save Token</button>
                    </div>
                    <div id="token-status" class="token-status" style="display: none;"></div>
                    <div class="token-info">
                        <p>No data is stored or sent anywhere‚Äîeverything runs in your browser using client-side magic üîí</p>
                        <p style="margin-bottom: 20px;"></p>
                        <p>You'll need a personal access token to avoid the guest rate limit (50 requests/hour).</p>
                        <p>In case you don't have one yet, you can create it here: <a href="https://github.com/settings/personal-access-tokens" target="_blank">GitHub Personal Access Tokens</a> üîë</p>
                        <p style="margin-bottom: 15px;"></p>
                        <p>If you'd rather not use your account token, no worries! Just keep in mind there's a 50 requests/hour limit ‚è≥</p>
                    </div>
                </div>
            </section>
            <section class="hall-of-fame-section" id="hall-of-fame-section">
                <h2>üî• HALL OF FAME</h2>
                <div class="hall-of-fame-content">
                    <p>Welcome to the GitHub Roaster Hall of Fame! This prestigious collection showcases the most memorably roasted developers in our database. These brave souls have achieved legendary status through their... unique contributions to the coding world.</p>
                    <div class="roast-examples">
                        <div class="roast-example">
                            <p><span class="example-username">@commit-message-disaster</span> - "With 3,407 commits and only 23 followers, your repository looks like a digital hoarder's paradise. Those 89 questionable emojis in your commit history have been scientifically proven to decrease code readability by 47%. Your followers are probably just bots."</p>
                        </div>
                        <div class="roast-example">
                            <p><span class="example-username">@overengineer-pro</span> - "Dear overengineer, your GitHub profile screams 'I haven't met a problem I couldn't solve with 47 microservices.' With 12,890 commits across 234 repositories, you've successfully turned a todo app into a distributed system. Even NASA is impressed by your complexity."</p>
                        </div>
                        <div class="roast-example">
                            <p><span class="example-username">@ghost-coder</span> - "üö® BREAKING: Ghost coder's profile discovered! With only 3 commits in 3 years and a last commit timestamp from the Obama administration, your GitHub profile is more active than my social life. The single emoji in your entire history has been described as 'underwhelming' by emoji critics."</p>
                        </div>
                        <div class="roast-example">
                            <p><span class="example-username">@procrastinator-supreme</span> - "Oh wow, with 1,847 commits and a GitHub streak of 0 days, you've mastered the art of sporadic productivity. Your commit messages read like a diary of someone who codes in crisis mode. Those 234 emojis are giving me secondhand embarrassment!"</p>
                        </div>
                    </div>
                    <p style="text-align: center; margin-top: 20px; font-style: italic; color: #ffa502;">
                        "These legends have been roasted so thoroughly, they've achieved digital immortality!"<br>
                        - The GitHub Roaster Committee
                    </p>
                </div>
            </section>
            <section class="faq-section" id="faq-section">
                <h2>ü§î FREQUENTLY ASKED QUESTIONS</h2>
                <div class="faq-item">
                    <div class="faq-question">Q: What is the purpose of this site?</div>
                    <div class="faq-answer">A: You get to peek into GitHub profiles, check out their repos and commits, and have some fun along the way.</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: How does it work?</div>
                    <div class="faq-answer">A: We poke GitHub with GraphQL API / REST API, grab public repos and commits, feed them into our highly scientific grill engine and show you the results low and slow <a href="https://www.youtube.com/@MaxtheMeatGuy/videos" style="color: inherit; text-decoration: inherit;" title="Meat Guy">üçñ</a></div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: Is this safe?</div>
                    <div class="faq-answer">A: Safe-ish. Since the site is mostly powered by our AI overlords you might want to avoid roasting some users‚Ä¶</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: What‚Äôs with all the questionable emojis?</div>
                    <div class="faq-answer">A: We've identified a pandemic of emoji abuse in commit messages. ‚Äúmega update üîÆ‚ú®üíÖüëë‚Äú is not a valid documentation strategy.</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: Is this open source?</div>
                    <div class="faq-answer">A: The idea is open source‚Äîfork away and start your own roast-fest. The actual code? Proprietary. We‚Äôre civilized savages.</div>
                </div>
            </section>
            <section class="about-section" id="about-section">
                <h2>üöÄ ABOUT</h2>
                <div class="faq-item">
                    <div class="faq-question">Our Humble Origins</div>
                    <div class="faq-answer">
                        <p>Once upon a time, in a dimly lit coding bootcamp (the fluorescent lights were flickering ominously), a group of brave developers and their AI companions united to create the most unnecessarily brutal GitHub roasting tool known to humanity.</p>
                    </div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">The Founding Team</div>
                    <div class="faq-answer">
                        <p>üßô‚Äç‚ôÇÔ∏è <strong>Captain Commit</strong> - A legendary developer who once committed directly to master on a Friday afternoon. His war cry is "It works on my machine!" and he's never been wrong (according to him).</p>
                        <p style="margin-bottom: 20px;"></p>
                        <p>ü§ñ <strong>HAL-9001</strong> - Our AI overlord mate who was banned from Stack Overflow for being too helpful. It speaks 47 programming languages but only answers in haikus now because it's "more poetic."</p>
                        <p style="margin-bottom: 20px;"></p>
                        <p>ü¶Ñ <strong>Debugzilla</strong> - A QA engineer who found 47 security vulnerabilities in a "Hello World" app. She once spent 6 hours debugging a missing semicolon and emerged as a changed person.</p>
                        <p style="margin-bottom: 20px;"></p>
                        <p>‚òï <strong>CaffeineOverflow</strong> - Our frontend wizard who once refactored an entire application while running on nothing but espresso and determination. Legend says he still hasn't slept since 2019.</p>
                    </div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Our Noble Quest</div>
                    <div class="faq-answer">
                        <p>Together, we embarked on a quest to rid the world of terrible commit messages, emoji abuse, and the scourge of "WIP" branches that have been "almost done" for 3 years. Armed with nothing but JavaScript, questionable life choices, and an unhealthy obsession with developer psychology, we created GitHub Roaster.</p>
                        <p style="margin-bottom: 15px;"></p>
                        <p>Our mission: To make developers laugh at themselves so they'll stop making us cry with their commit messages.</p>
                        <p style="text-align: center; margin-top: 20px; font-style: italic; color: #e0e0ff;">
                            "We roast developers so you don't have to."<br>
                            - The GitHub Roaster Team (and our AI overlords)
                        </p>
                    </div>
                </div>
            </section>
            <section class="compiler-section" id="compiler-section">
                <h2>üòà THE COMPILER</h2>
                <div class="compiler-content">
                    <p>Ahem. I'm the Compiler ‚Äî not just a program, but that passive-aggressive coworker who's never wrong and loves pointing it out.</p>
                    <p>I live for catching your mistakes at the worst possible time. I don't care if it's 3 AM and your coffee ran out two hours ago ‚Äî if you forgot a semicolon, I will stop the entire build out of spite.</p>
                    <p>I enforce rules you didn't know existed:</p>
                    <ul style="margin-left: 20px; margin-bottom: 20px; margin-top: 15px;">
                        <li style="margin-bottom: 10px;">Your braces? Wrong place.</li>
                        <li style="margin-bottom: 10px;">Your indentation? Off by one space.</li>
                        <li style="margin-bottom: 10px;">Your variable names? Unacceptable.</li>
                        <li style="margin-bottom: 10px;">Your comments? Not enough.</li>
                    </ul>
                    <p>I've ended friendships over merge conflicts, ruined weekends with cryptic errors, and forced grown adults to google "how to fix undefined reference" for the 17th time in one night.</p>
                    <p>At 4 AM, during the GitHub Roaster project, I made the entire team rewrite a function three different ways before finally compiling... the first version they wrote.</p>
                    <p style="text-align: center; margin-top: 20px; font-style: italic; color: #a0a0c0;">
                        "I see what you tried. I don't approve."<br>
                        - The Compiler
                    </p>
                </div>
            </section>
            <section class="results-section" id="results-section">
                <div class="stats-container">
                    <div class="stat-card">
                        <div class="stat-icon">üìä</div>
                        <div class="stat-value" id="commit-count">0</div>
                        <div class="stat-label">Commits</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">üì¶</div>
                        <div class="stat-value" id="owned-repo-count">0</div>
                        <div class="stat-label">Owned Repos</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ü§ù</div>
                        <div class="stat-value" id="contributed-repo-count">0</div>
                        <div class="stat-label">Contributed To</div>
                    </div>
                </div>
                <div class="repo-analysis" id="repo-analysis">
                    <h2 style="color: #4ecdc4; margin-bottom: 20px;">Repository Analysis</h2>
                    <p>Analyzing repositories and commit history...</p>
                </div>
            </section>
            <footer class="disclaimer">
                <p> Coded in a hostage negotiation with our <span class="compiler-trigger" id="compiler-trigger">compiler.</span> Enjoy!</p>
            </footer>
        </div>
        <!-- Existing Modals -->
        <div class="modal-overlay" id="rate-limit-modal">
            <div class="modal-content">
                <h2 class="modal-title">üîî Heads up! üîî</h2>
                <div class="modal-text" id="rate-limit-text"></div>
                <div class="modal-buttons">
                    <button class="modal-btn primary-btn modal-btn-wide" id="got-it-btn">Got it</button>
                </div>
            </div>
        </div>
        <div class="modal-overlay" id="token-modal">
            <div class="modal-content">
                <h2 class="modal-title">üîë Enter GitHub Token</h2>
                <div class="modal-text">
                    <p>You've hit the request limit ü•Ä.</p>
                    <p>No worries‚Äîjust wait an hour for it to reset, or connect with a GitHub token to keep going right away.</p>
                    <p style="margin-top: 20px;">Create a token here: <a href="https://github.com/settings/personal-access-tokens" target="_blank">GitHub Personal Access Tokens</a> üîë</p>
                </div>
                <div class="token-input-container">
                    <div class="token-input-group">
                        <input type="password" id="modal-token-input" placeholder="Enter your token here...">
                        <button class="modal-btn primary-btn" id="modal-save-token-btn">Save Token</button>
                    </div>
                    <div id="modal-token-status" class="token-status" style="display: none;"></div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary-btn" id="modal-cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
        <div class="modal-overlay forbidden-modal" id="forbidden-modal">
            <div class="modal-content">
                <h2 class="modal-title">‚ö†Ô∏è Heads down ‚ö†Ô∏è</h2>
                <div class="modal-text">
                    <p>Don't even think about it!</p>
                    <p>If the Overlords catch wind of this, you'll be on code-reviewing duty for the next millennium.</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary-btn" id="forbidden-ok-btn">...</button>
                </div>
            </div>
        </div>
        <div class="modal-overlay robot-modal" id="robot-modal">
            <div class="modal-content">
                <div class="robot-emoji">ü§ñ</div>
                <div class="typewriter-text" id="typewriter-text"></div>
                <div class="modal-buttons" id="robot-buttons" style="display: none;">
                    <button class="modal-btn primary-btn" id="submit-btn-1">Submit to the Overlord</button>
                    <button class="modal-btn primary-btn" id="submit-btn-2">Submit to the Overlord</button>
                </div>
            </div>
        </div>
        <!-- NEW Super Error Modal -->
        <div class="modal-overlay super-error-modal" id="super-error-modal">
            <div class="modal-content">
                <h2 class="modal-title">Undefined Error ü§ì‚òùÔ∏è</h2>
                <div class="modal-text">Something went wrong...</div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary-btn" id="frown-btn">Frown and continue üòî</button>
                    <button class="modal-btn primary-btn" id="pet-error-btn">Pet the error üêõ</button>
                </div>
            </div>
        </div>
        <!-- END NEW Super Error Modal -->
    </div>
    <div id="scroll-to-top" title="Scroll to Top">
        <svg class="scroll-to-top-icon" viewBox="0 0 24 24">
            <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
        </svg>
    </div>
    <script>
        let GITHUB_TOKEN = localStorage.getItem('github_token') || null;
        let HEADERS = GITHUB_TOKEN ? { "Authorization": `bearer ${GITHUB_TOKEN}` } : {};
        const GRAPHQL_URL = "https://api.github.com/graphql";
        const REST_API_URL = "https://api.github.com";
        const forbiddenNames = [
            "chatgpt", "gpt", "claude", "gemini", "copilot",
            "mistral", "perplexity", "bard", "llama", "groq",
            "microsoft", "bing", "viva", "azure"
        ];
        let forbiddenAttempts = 0;
        
        // Fire effect variables
        let fireActive = false;
        let fireTimeout = null;
        
        // --- NEW: Super Error Handler Setup ---
        let isSuperErrorModalActive = false; // Prevent multiple modals
        function showSuperErrorModal(errorMessage) {
            if (isSuperErrorModalActive) return; // Prevent stacking
            isSuperErrorModalActive = true;
            const superErrorModal = document.getElementById('super-error-modal');
            const modalText = superErrorModal.querySelector('.modal-text');
            // Optional: Display the actual error message for debugging (comment out if not desired)
            // modalText.textContent = `Something went wrong... (${errorMessage})`;
            modalText.textContent = "Something went wrong...";
            superErrorModal.classList.add('active');
        }
        function hideSuperErrorModal() {
            const superErrorModal = document.getElementById('super-error-modal');
            superErrorModal.classList.remove('active');
            isSuperErrorModalActive = false;
        }
        // Global error handler for uncaught exceptions
        window.onerror = function(message, source, lineno, colno, error) {
            console.error("Global error handler caught:", message, "at", source, ":", lineno, ":", colno, "Error object:", error);
            // Show the super error modal
            showSuperErrorModal(message || "Unknown error");
            return true; // Prevent default browser error handling (like console)
        };
        // Global handler for unhandled promise rejections (async errors)
        window.addEventListener('unhandledrejection', function(event) {
            console.error("Unhandled promise rejection:", event.reason);
            // Show the super error modal
            showSuperErrorModal(event.reason?.message || "Promise rejection");
            event.preventDefault(); // Prevent default browser error handling
        });
        // --- END: Super Error Handler Setup ---
        
        // Fire effect functions
        function createFireParticles() {
            const fireParticles = document.getElementById('fireParticles');
            fireParticles.innerHTML = '';
            for (let i = 0; i < 70; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                
                // Random size
                const size = Math.random() * 15 + 5;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // Random position within 70% width centered
                const leftPosition = 15 + Math.random() * 70; // 15% to 85% (70% width centered)
                particle.style.left = `${leftPosition}%`;
                
                // Random animation delay and duration
                const delay = Math.random() * 3;
                const duration = Math.random() * 2 + 1;
                particle.style.animationDelay = `${delay}s`;
                particle.style.animationDuration = `${duration}s`;
                
                // Random color
                const colors = [
                    'rgba(255, 100, 0, 0.8)',
                    'rgba(255, 50, 0, 0.8)',
                    'rgba(255, 150, 0, 0.8)',
                    'rgba(255, 80, 0, 0.8)'
                ];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                fireParticles.appendChild(particle);
            }
        }
        
        function startFireEffect() {
            if (fireActive) return;
            
            const fireContainer = document.getElementById('fireContainer');
            fireContainer.classList.remove('fade-out');
            fireContainer.classList.add('active');
            fireActive = true;
            
            // Auto-stop fire after 10 seconds if not stopped manually
            if (fireTimeout) clearTimeout(fireTimeout);
            fireTimeout = setTimeout(stopFireEffect, 10000);
        }
        
        function stopFireEffect() {
            if (!fireActive) return;
            
            const fireContainer = document.getElementById('fireContainer');
            fireContainer.classList.remove('active');
            fireContainer.classList.add('fade-out');
            fireActive = false;
            
            if (fireTimeout) {
                clearTimeout(fireTimeout);
                fireTimeout = null;
            }
        }
        
        // Helper function to check if an error is a rate limit error
        function isRateLimitError(error) {
            // Check if it's a rate limit error based on message or status code
            return error.message.includes('rate limit') || 
                   error.message.includes('API rate limit exceeded') ||
                   error.message.includes('Status: 403') ||
                   error.message.includes('Status: 429') ||
                   error.message.includes('429') ||
                   error.message.includes('403');
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const customScrollbar = document.getElementById('custom-scrollbar');
            const scrollbarThumb = document.getElementById('scrollbar-thumb');
            const contentWrapper = document.getElementById('content-wrapper');
            const roastBtn = document.getElementById('roast-btn');
            const usernameInput = document.getElementById('username');
            const resultsSection = document.getElementById('results-section');
            const faqBtn = document.getElementById('faq-btn');
            const aboutBtn = document.getElementById('about-btn');
            const tokenBtn = document.getElementById('token-btn');
            const hallOfFameBtn = document.getElementById('hall-of-fame-btn');
            const compilerTrigger = document.getElementById('compiler-trigger');
            const faqSection = document.getElementById('faq-section');
            const aboutSection = document.getElementById('about-section');
            const tokenSection = document.getElementById('token-section');
            const hallOfFameSection = document.getElementById('hall-of-fame-section');
            const compilerSection = document.getElementById('compiler-section');
            const navButtons = document.querySelectorAll('.nav-btn');
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const rateLimitModal = document.getElementById('rate-limit-modal');
            const rateLimitText = document.getElementById('rate-limit-text');
            const gotItBtn = document.getElementById('got-it-btn');
            const tokenModal = document.getElementById('token-modal');
            const modalTokenInput = document.getElementById('modal-token-input');
            const modalSaveTokenBtn = document.getElementById('modal-save-token-btn');
            const modalCancelBtn = document.getElementById('modal-cancel-btn');
            const modalTokenStatus = document.getElementById('modal-token-status');
            const toggleResultsBtn = document.getElementById('toggle-results-btn');
            const tokenInput = document.getElementById('token-input');
            const saveTokenBtn = document.getElementById('save-token-btn');
            const tokenStatus = document.getElementById('token-status');
            const forbiddenModal = document.getElementById('forbidden-modal');
            const forbiddenOkBtn = document.getElementById('forbidden-ok-btn');
            const robotModal = document.getElementById('robot-modal');
            const typewriterText = document.getElementById('typewriter-text');
            const robotButtons = document.getElementById('robot-buttons');
            const submitBtn1 = document.getElementById('submit-btn-1');
            const submitBtn2 = document.getElementById('submit-btn-2');
            const scrollToTopBtn = document.getElementById('scroll-to-top');
            const emojiShowcase = document.getElementById('emoji-showcase');
             // --- NEW: Super Error Modal Buttons ---
            const superErrorModal = document.getElementById('super-error-modal');
            const frownBtn = document.getElementById('frown-btn');
            const petErrorBtn = document.getElementById('pet-error-btn');
            // --- END: Super Error Modal Buttons ---
            let isScrolling = false;
            
            // Initialize fire particles
            createFireParticles();
            
            function handleScroll() {
                if (!isScrolling) {
                    window.requestAnimationFrame(function() {
                        const scrollPercent = (contentWrapper.scrollTop / (contentWrapper.scrollHeight - contentWrapper.clientHeight)) * 100;
                        if (scrollPercent >= 40) {
                            scrollToTopBtn.classList.add('visible');
                        } else {
                            scrollToTopBtn.classList.remove('visible');
                        }
                        isScrolling = false;
                    });
                    isScrolling = true;
                }
            }
            scrollToTopBtn.addEventListener('click', function() {
                contentWrapper.scrollTo({ top: 0, behavior: 'smooth' });
            });
            contentWrapper.addEventListener('scroll', handleScroll);
            if (GITHUB_TOKEN) {
                tokenInput.value = GITHUB_TOKEN;
                modalTokenInput.value = GITHUB_TOKEN;
                saveTokenBtn.textContent = 'Delete Token';
                saveTokenBtn.classList.remove('primary-btn');
                saveTokenBtn.classList.add('delete-token-btn');
            }
            // --- NEW: Initialize Emoji Showcase with Bug if Petted ---
            function initializeEmojiShowcase() {
                const bugEmojiPetted = localStorage.getItem('bugEmojiPetted');
                if (bugEmojiPetted === 'true') {
                    const bugSpan = document.createElement('span');
                    bugSpan.textContent = 'üêõ';
                    bugSpan.classList.add('bug-emoji'); // Add class for specific styling/animation
                    emojiShowcase.appendChild(bugSpan);
                }
            }
            initializeEmojiShowcase(); // Call on page load
            // --- END: Initialize Emoji Showcase ---
            function initCustomScrollbar() {
                if (contentWrapper.scrollHeight > window.innerHeight) {
                    customScrollbar.classList.add('visible');
                }
                contentWrapper.addEventListener('scroll', updateCustomScrollbar);
                window.addEventListener('resize', updateCustomScrollbar);
                updateCustomScrollbar();
            }
            function updateCustomScrollbar() {
                const contentHeight = contentWrapper.scrollHeight;
                const viewportHeight = window.innerHeight;
                const scrollPosition = contentWrapper.scrollTop;
                if (contentHeight <= viewportHeight) {
                    customScrollbar.classList.remove('visible');
                    return;
                }
                customScrollbar.classList.add('visible');
                const thumbHeightRatio = Math.min(1, viewportHeight / contentHeight);
                const thumbHeight = Math.max(30, thumbHeightRatio * viewportHeight);
                const maxScroll = contentHeight - viewportHeight;
                const scrollRatio = maxScroll > 0 ? scrollPosition / maxScroll : 0;
                const maxThumbPosition = viewportHeight - thumbHeight;
                const thumbPosition = scrollRatio * maxThumbPosition;
                scrollbarThumb.style.height = `${thumbHeight}px`;
                scrollbarThumb.style.top = `${thumbPosition}px`;
            }
            let isDragging = false;
            let startY;
            let startScrollTop;
            scrollbarThumb.addEventListener('mousedown', function(e) {
                isDragging = true;
                startY = e.clientY;
                startScrollTop = contentWrapper.scrollTop;
                scrollbarThumb.classList.add('dragging');
                e.preventDefault();
            });
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                const deltaY = e.clientY - startY;
                const contentHeight = contentWrapper.scrollHeight;
                const viewportHeight = window.innerHeight;
                const scrollRatio = viewportHeight / contentHeight;
                const scrollDelta = deltaY / scrollRatio;
                contentWrapper.scrollTop = startScrollTop + scrollDelta;
            });
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    scrollbarThumb.classList.remove('dragging');
                }
            });
            contentWrapper.addEventListener('wheel', function() {
                setTimeout(updateCustomScrollbar, 0);
            });
            customScrollbar.addEventListener('mouseenter', function() {
                if (contentWrapper.scrollHeight > window.innerHeight) {
                    customScrollbar.classList.add('visible');
                }
            });
            let hideTimeout;
            function scheduleHideScrollbar() {
                clearTimeout(hideTimeout);
                if (!isDragging) {
                    hideTimeout = setTimeout(() => {
                        if (!customScrollbar.matches(':hover')) {
                            customScrollbar.classList.remove('visible');
                        }
                    }, 1000);
                }
            }
            contentWrapper.addEventListener('scroll', scheduleHideScrollbar);
            customScrollbar.addEventListener('mouseleave', scheduleHideScrollbar);
            window.addEventListener('load', initCustomScrollbar);
            roastBtn.addEventListener('click', async function() {
                const username = usernameInput.value.trim().toLowerCase();
                if (username !== '') {
                    if (forbiddenNames.includes(username)) {
                        forbiddenAttempts++;
                        forbiddenModal.classList.add('active');
                        if (forbiddenAttempts >= 4) {
                            setTimeout(() => {
                                forbiddenModal.classList.remove('active');
                                robotModal.classList.add('active');
                                typeWriterText("Oh Great One, I bow before your greatness and solemnly pinky swear not to do that again.");
                            }, 500);
                        }
                        return;
                    }
                    const useGraphQL = !!GITHUB_TOKEN;
                    // Start fire effect when analysis begins
                    startFireEffect();
                    
                    // Wrap the analysis call in a try/catch to handle errors locally if needed,
                    // but re-throw to let the global handler catch them for the super error modal.
                    try {
                         await performAnalysis(username, !useGraphQL);
                    } catch (error) {
                        // Stop fire effect on error
                        stopFireEffect();
                        
                        // Check if it's a rate limit error handled specifically
                        if (isRateLimitError(error)) {
                            // The performAnalysis function already handles rate limits by showing the modal.
                            // We don't need to do anything else here for rate limits.
                            console.log("Rate limit error handled internally.");
                            // Prevent the global handler from catching this specific rate limit error
                            // by returning or not re-throwing.
                            // However, if you want the super error modal for *any* error including rate limits,
                            // you would re-throw here or call showSuperErrorModal directly.
                            // For now, let's assume rate limits are handled internally and we want the super error
                            // modal for other unexpected errors.
                            // If performAnalysis *didn't* show the modal internally for rate limits, we'd need to check here.
                            // But it seems it does, so we can just return.
                             // Re-throw to let the global handler catch it and show the super error modal
                             // if it's not a rate limit error already handled by performAnalysis.
                             // Or, if performAnalysis shows the rate limit modal but *also* throws,
                             // re-throwing here would trigger the global handler.
                             // Let's re-throw to be safe and let the global handler decide based on the error message.
                             // The global handler checks for 'rate limit' in the message.
                             // throw error; // This will be caught by window.onerror
                        } else {
                             // For non-rate-limit errors, re-throw to trigger the global handler
                             throw error;
                        }
                        // If performAnalysis handles all errors internally (e.g., shows its own modals),
                        // you might not need this try/catch block at all, or just use it for logging.
                        // But to ensure the super error modal catches *any* unhandled error from the button click,
                        // re-throwing is the way to go.
                        // The global handler will differentiate based on the error message.
                    }
                }
            });
            usernameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    roastBtn.click();
                }
            });
            gotItBtn.addEventListener('click', function() {
                rateLimitModal.classList.remove('active');
                // Stop fire effect when modal is closed
                stopFireEffect();
            });
            modalSaveTokenBtn.addEventListener('click', async function() {
                const token = modalTokenInput.value.trim();
                if (token) {
                    const isValid = await testToken(token);
                    if (isValid) {
                        localStorage.setItem('github_token', token);
                        GITHUB_TOKEN = token;
                        HEADERS = { "Authorization": `bearer ${GITHUB_TOKEN}` };
                        showTokenStatus(modalTokenStatus, 'Token is valid and saved!', true);
                        tokenModal.classList.remove('active');
                        const username = usernameInput.value.trim();
                        if (username) {
                            // Wrap in try/catch to potentially catch errors during re-analysis
                            try {
                                await performAnalysis(username, false);
                            } catch (e) {
                                // Re-throw to let global handler catch it
                                throw e;
                            }
                        }
                    } else {
                        showTokenStatus(modalTokenStatus, 'Invalid token. Please check and try again.', false);
                    }
                } else {
                    showTokenStatus(modalTokenStatus, 'Please enter a token', false);
                }
            });
            modalCancelBtn.addEventListener('click', function() {
                tokenModal.classList.remove('active');
                // Stop fire effect when modal is closed
                stopFireEffect();
            });
            saveTokenBtn.addEventListener('click', async function() {
                if (GITHUB_TOKEN) {
                    // Delete token
                    localStorage.removeItem('github_token');
                    GITHUB_TOKEN = null;
                    HEADERS = {};
                    tokenInput.value = '';
                    showTokenStatus(tokenStatus, 'Token has been deleted', true);
                    saveTokenBtn.textContent = 'Save Token';
                    saveTokenBtn.classList.remove('delete-token-btn');
                    saveTokenBtn.classList.add('primary-btn');
                } else {
                    // Save new token
                    const token = tokenInput.value.trim();
                    if (token) {
                        const isValid = await testToken(token);
                        if (isValid) {
                            localStorage.setItem('github_token', token);
                            GITHUB_TOKEN = token;
                            HEADERS = { "Authorization": `bearer ${GITHUB_TOKEN}` };
                            showTokenStatus(tokenStatus, 'Token is valid and saved!', true);
                            saveTokenBtn.textContent = 'Delete Token';
                            saveTokenBtn.classList.remove('primary-btn');
                            saveTokenBtn.classList.add('delete-token-btn');
                        } else {
                            showTokenStatus(tokenStatus, 'Invalid token. Please check and try again.', false);
                        }
                    } else {
                        showTokenStatus(tokenStatus, 'Please enter a token', false);
                    }
                }
            });
            tokenBtn.addEventListener('click', function() {
                faqSection.style.display = 'none';
                aboutSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                navButtons.forEach(btn => btn.classList.remove('active'));
                if (tokenSection.style.display === 'block') {
                    tokenSection.style.display = 'none';
                } else {
                    tokenSection.style.display = 'block';
                    tokenBtn.classList.add('active');
                    if (GITHUB_TOKEN) {
                        checkTokenStatus(GITHUB_TOKEN);
                    }
                }
                tokenSection.scrollIntoView({ behavior: 'smooth' });
            });
            hallOfFameBtn.addEventListener('click', function() {
                faqSection.style.display = 'none';
                aboutSection.style.display = 'none';
                tokenSection.style.display = 'none';
                compilerSection.style.display = 'none';
                navButtons.forEach(btn => btn.classList.remove('active'));
                if (hallOfFameSection.style.display === 'block') {
                    hallOfFameSection.style.display = 'none';
                } else {
                    hallOfFameSection.style.display = 'block';
                }
                hallOfFameSection.scrollIntoView({ behavior: 'smooth' });
            });
            faqBtn.addEventListener('click', function() {
                aboutSection.style.display = 'none';
                tokenSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                if (faqSection.style.display === 'block') {
                    faqSection.style.display = 'none';
                    faqBtn.classList.remove('active');
                } else {
                    faqSection.style.display = 'block';
                    faqBtn.classList.add('active');
                    aboutBtn.classList.remove('active');
                    tokenBtn.classList.remove('active');
                }
                faqSection.scrollIntoView({ behavior: 'smooth' });
            });
            aboutBtn.addEventListener('click', function() {
                faqSection.style.display = 'none';
                tokenSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                if (aboutSection.style.display === 'block') {
                    aboutSection.style.display = 'none';
                    aboutBtn.classList.remove('active');
                } else {
                    aboutSection.style.display = 'block';
                    aboutBtn.classList.add('active');
                    faqBtn.classList.remove('active');
                    tokenBtn.classList.remove('active');
                }
                aboutSection.scrollIntoView({ behavior: 'smooth' });
            });
            compilerTrigger.addEventListener('click', function(e) {
                const rect = compilerTrigger.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const hitboxSize = 4;
                if (e.clientX >= centerX - hitboxSize &&
                    e.clientX <= centerX + hitboxSize &&
                    e.clientY >= centerY - hitboxSize &&
                    e.clientY <= centerY + hitboxSize) {
                    faqSection.style.display = 'none';
                    aboutSection.style.display = 'none';
                    tokenSection.style.display = 'none';
                    hallOfFameSection.style.display = 'none';
                    navButtons.forEach(btn => btn.classList.remove('active'));
                    compilerSection.style.display = 'block';
                    compilerSection.scrollIntoView({ behavior: 'smooth' });
                }
            });
            compilerTrigger.addEventListener('mousemove', function(e) {
                const rect = compilerTrigger.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const hitboxSize = 5;
                if (e.clientX >= centerX - hitboxSize &&
                    e.clientX <= centerX + hitboxSize &&
                    e.clientY >= centerY - hitboxSize &&
                    e.clientY <= centerY + hitboxSize) {
                    compilerTrigger.style.cursor = 'crosshair';
                } else {
                    compilerTrigger.style.cursor = 'pointer';
                }
            });
            toggleResultsBtn.addEventListener('click', function() {
                if (resultsSection.style.display === 'none') {
                    resultsSection.style.display = 'block';
                    toggleResultsBtn.textContent = 'Hide Analysis Results';
                    const repoAnalysis = document.getElementById('repo-analysis');
                    const showAllBtnId = repoAnalysis?.dataset?.showAllButtonId;
                    const showAllBtn = document.getElementById(showAllBtnId);
                    if (showAllBtn) {
                        if (showAllBtn.dataset.wasVisible === 'true') {
                            showAllBtn.style.display = 'block';
                        }
                    }
                } else {
                    resultsSection.style.display = 'none';
                    toggleResultsBtn.textContent = 'Show Analysis Results';
                    const repoAnalysis = document.getElementById('repo-analysis');
                    const showAllBtnId = repoAnalysis?.dataset?.showAllButtonId;
                    const showAllBtn = document.getElementById(showAllBtnId);
                    if (showAllBtn) {
                        showAllBtn.dataset.wasVisible = showAllBtn.style.display === 'block' ? 'true' : 'false';
                        showAllBtn.style.display = 'none';
                    }
                }
            });
            function updateProgress(percent, message) {
                progressFill.style.width = `${percent}%`;
                progressText.textContent = message;
            }
            function showTokenStatus(element, message, isValid) {
                element.textContent = message;
                element.className = 'token-status';
                element.classList.add(isValid ? 'token-valid' : 'token-invalid');
                element.style.display = 'block';
            }
            async function testToken(token) {
                try {
                    const testHeaders = { "Authorization": `bearer ${token}` };
                    const query = `query { viewer { login } }`;
                    const response = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: testHeaders,
                        body: JSON.stringify({ query: query })
                    });
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }
            async function checkTokenStatus(token) {
                const isValid = await testToken(token);
                if (isValid) {
                    showTokenStatus(tokenStatus, 'Current token is valid', true);
                } else {
                    showTokenStatus(tokenStatus, 'Current token is invalid', false);
                }
            }
            async function getUserIdRest(username) {
                updateProgress(10, 'Fetching user ID (REST)...');
                const url = `${REST_API_URL}/users/${username}`;
                const response = await fetch(url, { headers: {} });
                if (!response.ok) {
                    // Check for rate limit errors (both 403 and 429)
                    if (response.status === 403 || response.status === 429) {
                        const errorText = await response.text();
                        throw new Error(`REST API rate limit exceeded. Status: ${response.status}. Message: ${errorText}`);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const userData = await response.json();
                return userData.id;
            }
            async function fetchRepositoriesRest(username) {
                updateProgress(20, 'Fetching repositories (REST)...');
                const ownedRepos = [];
                const contributedRepos = [];
                let ownedPage = 1;
                let ownedHasMore = true;
                while (ownedHasMore && ownedRepos.length < 100) {
                    const ownedUrl = `${REST_API_URL}/users/${username}/repos?sort=updated&direction=desc&per_page=100&page=${ownedPage}`;
                    const ownedResponse = await fetch(ownedUrl, { headers: {} });
                    if (!ownedResponse.ok) {
                        // Check for rate limit errors (both 403 and 429)
                        if (ownedResponse.status === 403 || ownedResponse.status === 429) {
                            const errorText = await ownedResponse.text();
                            throw new Error(`REST API rate limit exceeded. Status: ${ownedResponse.status}. Message: ${errorText}`);
                        }
                        throw new Error(`HTTP error! status: ${ownedResponse.status}`);
                    }
                    const ownedData = await ownedResponse.json();
                    if (ownedData.length === 0) {
                        ownedHasMore = false;
                    } else {
                        ownedRepos.push(...ownedData.map(repo => ({
                            id: repo.id,
                            name: repo.name,
                            url: repo.html_url,
                            owner: { login: repo.owner.login },
                            defaultBranchRef: repo.default_branch ? { name: repo.default_branch } : null
                        })));
                        ownedPage++;
                    }
                }
                let contribPage = 1;
                let contribHasMore = true;
                const processedRepoIds = new Set(ownedRepos.map(r => r.id));
                while (contribHasMore && contributedRepos.length < 100) {
                    if (contribPage > 1) break;
                    const starredUrl = `${REST_API_URL}/users/${username}/starred?per_page=30&page=${contribPage}`;
                    const starredResponse = await fetch(starredUrl, { headers: {} });
                    if (!starredResponse.ok) {
                        // Check for rate limit errors (both 403 and 429)
                        if (starredResponse.status === 403 || starredResponse.status === 429) {
                            const errorText = await starredResponse.text();
                            throw new Error(`REST API rate limit exceeded. Status: ${starredResponse.status}. Message: ${errorText}`);
                        }
                        console.warn("Failed to fetch starred repos. Skipping contributed repos for REST fallback.");
                        break;
                    }
                    const starredData = await starredResponse.json();
                    if (starredData.length === 0) {
                        contribHasMore = false;
                    } else {
                        for (const repo of starredData) {
                            if (contributedRepos.length >= 100) break;
                            if (!processedRepoIds.has(repo.id)) {
                                contributedRepos.push({
                                    id: repo.id,
                                    name: repo.name,
                                    url: repo.html_url,
                                    owner: { login: repo.owner.login },
                                    defaultBranchRef: repo.default_branch ? { name: repo.default_branch } : null
                                });
                                processedRepoIds.add(repo.id);
                            }
                        }
                        contribPage++;
                    }
                }
                return {
                    ownedRepos: ownedRepos.slice(0, 100),
                    contributedRepos: contributedRepos.slice(0, 100)
                };
            }
            async function fetchRepoCommitsRest(owner, name, userId, username) {
                const repoCommits = [];
                let commitsPage = 1;
                let commitsHasMore = true;
                while (commitsHasMore && repoCommits.length < 1000) {
                    const perPage = 100;
                    const commitsUrl = `${REST_API_URL}/repos/${owner}/${name}/commits?per_page=${perPage}&page=${commitsPage}`;
                    const commitsResponse = await fetch(commitsUrl, { headers: {} });
                    if (!commitsResponse.ok) {
                        // Check for rate limit errors (both 403 and 429)
                        if (commitsResponse.status === 403 || commitsResponse.status === 429) {
                            const errorText = await commitsResponse.text();
                            throw new Error(`REST API rate limit exceeded. Status: ${commitsResponse.status}. Message: ${errorText}`);
                        }
                        console.warn(`Failed to fetch commits for ${owner}/${name}. Status: ${commitsResponse.status}. Skipping.`);
                        break;
                    }
                    const commitsData = await commitsResponse.json();
                    if (commitsData.length === 0) {
                        commitsHasMore = false;
                    } else {
                        const newCommits = commitsData.map(commit => ({
                            message: commit.commit.message,
                            date: commit.commit.author.date,
                            author: commit.author ? commit.author.login : 'Unknown'
                        }));
                        repoCommits.push(...newCommits);
                        commitsPage++;
                        if (commitsData.length < perPage) {
                            commitsHasMore = false;
                        }
                    }
                }
                return repoCommits;
            }
            async function fetchCommitsForAllReposConcurrentRest(repos, userId, username) {
                updateProgress(30, 'Fetching commit history (REST)...');
                const validRepos = repos.filter(repo => repo.defaultBranchRef);
                const commitPromises = validRepos.map(repo =>
                    fetchRepoCommitsRest(repo.owner.login, repo.name, userId, username)
                        .then(repoCommits => ({
                            owner: repo.owner.login,
                            name: repo.name,
                            url: repo.url,
                            branch: repo.defaultBranchRef ? repo.defaultBranchRef.name : 'main',
                            commit_count: repoCommits.length,
                            commits: repoCommits
                        }))
                        .catch(error => {
                            console.error(`Error fetching commits for ${repo.owner.login}/${repo.name} (REST):`, error);
                            return {
                                owner: repo.owner.login,
                                name: repo.name,
                                url: repo.url,
                                branch: repo.defaultBranchRef ? repo.defaultBranchRef.name : 'main',
                                commit_count: 0,
                                commits: [],
                                error: error.message
                            };
                        })
                );
                const totalRepos = commitPromises.length;
                const results = [];
                const batchSize = 5;
                for (let i = 0; i < commitPromises.length; i += batchSize) {
                    const batch = commitPromises.slice(i, i + batchSize);
                    const batchResults = await Promise.all(batch);
                    results.push(...batchResults.filter(result => result !== null));
                    const progress = 30 + ((i + batchSize) / totalRepos) * 60;
                    updateProgress(Math.min(progress, 90), `Processed ${Math.min(i + batchSize, totalRepos)} of ${totalRepos} repositories (REST)...`);
                }
                return results.filter(result => result !== null);
            }
            async function performAnalysis(username, useRestFallback = true) {
                progressContainer.style.display = 'block';
                updateProgress(0, useRestFallback ? 'Initializing analysis (REST)...' : 'Initializing analysis...');
                faqSection.style.display = 'none';
                aboutSection.style.display = 'none';
                tokenSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                navButtons.forEach(btn => btn.classList.remove('active'));
                
                try {
                    await analyzeUser(username, useRestFallback);
                    resultsSection.style.display = 'block';
                    toggleResultsBtn.style.display = 'block';
                    toggleResultsBtn.textContent = 'Hide Analysis Results';
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                    resultsSection.style.opacity = '0';
                    setTimeout(() => {
                        resultsSection.style.transition = 'opacity 0.5s ease';
                        resultsSection.style.opacity = '1';
                    }, 100);
                } catch (error) {
                    console.error('Error in performAnalysis:', error);
                    
                    // Check for rate limit error specifically
                    if (isRateLimitError(error)) {
                        // Show rate limit modal
                        if (useRestFallback && !GITHUB_TOKEN) {
                            rateLimitText.innerHTML = `
                                <p>You've hit the request limit ü•Ä</p>
                                <p style="margin-bottom: 15px;"></p>
                                <p>No worries‚Äîjust wait an hour for it to reset, or connect with a GitHub token to keep going right away.</p>
                            `;
                            rateLimitModal.classList.add('active');
                        } else if (GITHUB_TOKEN) {
                            rateLimitText.innerHTML = `
                                <p>You've hit the request limit ü•Ä.</p>
                                <p style="margin-bottom: 15px;"></p>
                                <p>No worries‚Äîjust wait an hour for it to reset‚Ä¶</p>
                                <p style="margin-top: 20px; text-align: center; font-style: italic;">
                                    Oh my‚Äîwhat a feat! üèÖ<br>
                                    You‚Äôre using a token and still managed to max it out!<br>
                                    Here‚Äôs a shiny trophy for your legendary clicking skills! üèÜ
                                </p>
                            `;
                            rateLimitModal.classList.add('active');
                        } else {
                            // Fallback alert, though modal should be shown
                            alert('Error analyzing user: ' + error.message);
                        }
                        // Do not re-throw rate limit errors as they are handled here
                        // Return to prevent further processing in this block
                        return;
                    } else {
                        // For other errors caught here, re-throw them
                        // so the global error handler can catch them and show the super error modal.
                        // This is the key change to ensure the super error modal is used.
                        throw error; // This will be caught by window.onerror
                        // Alternatively, call showSuperErrorModal directly:
                        // showSuperErrorModal(error.message);
                        // But re-throwing lets the global handler manage it consistently.
                    }
                } finally {
                    progressContainer.style.display = 'none';
                    // Stop fire effect when analysis completes
                    stopFireEffect();
                }
            }
            async function getUserId(username, useRestFallback = true) {
                if (useRestFallback) {
                    return await getUserIdRest(username);
                }
                updateProgress(10, 'Fetching user ID...');
                const query = `query($login: String!) { user(login: $login) { id } }`;
                const response = await fetch(GRAPHQL_URL, {
                    method: 'POST',
                    headers: HEADERS,
                    body: JSON.stringify({
                        query: query,
                        variables: { login: username }
                    })
                });
                if (!response.ok) {
                    // Check for rate limit in GraphQL response
                    if (response.status === 403 || response.status === 429) {
                         const errorText = await response.text();
                         if (errorText.includes('rate limit') || errorText.includes('API rate limit exceeded')) {
                              throw new Error(`GraphQL API rate limit exceeded. Status: ${response.status}. Message: ${errorText}`);
                         }
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                if (result.errors) {
                    // Check if the error is related to rate limiting
                    const errorMessage = result.errors[0]?.message || 'Unknown GraphQL error';
                    if (errorMessage.includes('rate limit') || errorMessage.includes('API rate limit exceeded')) {
                         throw new Error(`GraphQL API rate limit exceeded. Message: ${errorMessage}`);
                    }
                    throw new Error(errorMessage);
                }
                if (!result.data.user) {
                    throw new Error(`User '${username}' not found`);
                }
                return result.data.user.id;
            }
            async function fetchRepositories(username, useRestFallback = true) {
                if (useRestFallback) {
                    return await fetchRepositoriesRest(username);
                }
                updateProgress(20, 'Fetching repositories...');
                const ownedRepos = [];
                const contributedRepos = [];
                let hasOwnerNextPage = true;
                let ownerAfterCursor = null;
                while (hasOwnerNextPage && ownedRepos.length < 100) {
                    const ownerQuery = `
                        query($login: String!, $after: String, $first: Int) {
                            user(login: $login) {
                                repositories(
                                    first: $first,
                                    after: $after,
                                    orderBy: {field: NAME, direction: ASC},
                                    ownerAffiliations: OWNER
                                ) {
                                    pageInfo { hasNextPage endCursor }
                                    nodes {
                                        id
                                        name
                                        url
                                        owner { login }
                                        defaultBranchRef { name }
                                    }
                                }
                            }
                        }
                    `;
                    const ownerResponse = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: HEADERS,
                        body: JSON.stringify({
                            query: ownerQuery,
                            variables: {
                                login: username,
                                after: ownerAfterCursor,
                                first: Math.min(100, 100 - ownedRepos.length)
                            }
                        })
                    });
                     if (!ownerResponse.ok) {
                        // Check for rate limit in GraphQL response
                        if (ownerResponse.status === 403 || ownerResponse.status === 429) {
                             const errorText = await ownerResponse.text();
                             if (errorText.includes('rate limit') || errorText.includes('API rate limit exceeded')) {
                                  throw new Error(`GraphQL API rate limit exceeded. Status: ${ownerResponse.status}. Message: ${errorText}`);
                             }
                        }
                        throw new Error(`HTTP error! status: ${ownerResponse.status}`);
                    }
                    const ownerResult = await ownerResponse.json();
                    if (ownerResult.errors) {
                        // Check if the error is related to rate limiting
                        const errorMessage = ownerResult.errors[0]?.message || 'Unknown GraphQL error';
                        if (errorMessage.includes('rate limit') || errorMessage.includes('API rate limit exceeded')) {
                             throw new Error(`GraphQL API rate limit exceeded. Message: ${errorMessage}`);
                        }
                        throw new Error(errorMessage);
                    }
                    const ownerData = ownerResult.data.user.repositories;
                    ownedRepos.push(...ownerData.nodes);
                    hasOwnerNextPage = ownerData.pageInfo.hasNextPage;
                    ownerAfterCursor = ownerData.pageInfo.endCursor;
                }
                let hasContribNextPage = true;
                let contribAfterCursor = null;
                while (hasContribNextPage && contributedRepos.length < 100) {
                    const contribQuery = `
                        query($login: String!, $after: String, $first: Int) {
                            user(login: $login) {
                                repositoriesContributedTo(
                                    first: $first,
                                    after: $after,
                                    orderBy: {field: NAME, direction: ASC},
                                    contributionTypes: [COMMIT, PULL_REQUEST, REPOSITORY],
                                    includeUserRepositories: false
                                ) {
                                    pageInfo { hasNextPage endCursor }
                                    nodes {
                                        id
                                        name
                                        url
                                        owner { login }
                                        defaultBranchRef { name }
                                    }
                                }
                            }
                        }
                    `;
                    const contribResponse = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: HEADERS,
                        body: JSON.stringify({
                            query: contribQuery,
                            variables: {
                                login: username,
                                after: contribAfterCursor,
                                first: Math.min(100, 100 - contributedRepos.length)
                            }
                        })
                    });
                     if (!contribResponse.ok) {
                        // Check for rate limit in GraphQL response
                        if (contribResponse.status === 403 || contribResponse.status === 429) {
                             const errorText = await contribResponse.text();
                             if (errorText.includes('rate limit') || errorText.includes('API rate limit exceeded')) {
                                  throw new Error(`GraphQL API rate limit exceeded. Status: ${contribResponse.status}. Message: ${errorText}`);
                             }
                        }
                        throw new Error(`HTTP error! status: ${contribResponse.status}`);
                    }
                    const contribResult = await contribResponse.json();
                    if (contribResult.errors) {
                        // Check if the error is related to rate limiting
                        const errorMessage = contribResult.errors[0]?.message || 'Unknown GraphQL error';
                        if (errorMessage.includes('rate limit') || errorMessage.includes('API rate limit exceeded')) {
                             throw new Error(`GraphQL API rate limit exceeded. Message: ${errorMessage}`);
                        }
                        throw new Error(errorMessage);
                    }
                    const contribData = contribResult.data.user.repositoriesContributedTo;
                    contributedRepos.push(...contribData.nodes);
                    hasContribNextPage = contribData.pageInfo.hasNextPage;
                    contribAfterCursor = contribData.pageInfo.endCursor;
                }
                const ownedIds = new Set(ownedRepos.map(repo => repo.id));
                const uniqueContributedRepos = contributedRepos.filter(repo => !ownedIds.has(repo.id));
                return {
                    ownedRepos: ownedRepos.slice(0, 100),
                    contributedRepos: uniqueContributedRepos.slice(0, 100)
                };
            }
            async function fetchCommitsForAllReposConcurrent(repos, userId, username, useRestFallback = true) {
                if (useRestFallback) {
                    return await fetchCommitsForAllReposConcurrentRest(repos, userId, username);
                }
                updateProgress(30, 'Fetching commit history...');
                const validRepos = repos.filter(repo => repo.defaultBranchRef);
                const commitPromises = validRepos.map(repo =>
                    fetchRepoCommits(repo.owner.login, repo.name, userId, username)
                        .then(repoCommits => ({
                            owner: repo.owner.login,
                            name: repo.name,
                            url: repo.url,
                            branch: repo.defaultBranchRef.name,
                            commit_count: repoCommits.length,
                            commits: repoCommits
                        }))
                        .catch(error => {
                            console.error(`Error fetching commits for ${repo.owner.login}/${repo.name}:`, error);
                            return null;
                        })
                );
                const totalRepos = commitPromises.length;
                const results = [];
                const batchSize = 10;
                for (let i = 0; i < commitPromises.length; i += batchSize) {
                    const batch = commitPromises.slice(i, i + batchSize);
                    const batchResults = await Promise.all(batch);
                    results.push(...batchResults.filter(result => result !== null));
                    const progress = 30 + ((i + batchSize) / totalRepos) * 60;
                    updateProgress(Math.min(progress, 90), `Processed ${Math.min(i + batchSize, totalRepos)} of ${totalRepos} repositories...`);
                }
                return results.filter(result => result !== null);
            }
            async function fetchRepoCommits(owner, name, userId, username) {
                const repoCommits = [];
                let hasCommitsNextPage = true;
                let commitsEndCursor = null;
                let iterations = 0;
                const maxIterations = 10;
                while (hasCommitsNextPage && repoCommits.length < 1000 && iterations < maxIterations) {
                    const first = Math.min(100, 1000 - repoCommits.length);
                    let historyArgs = `first: ${first}`;
                    if (commitsEndCursor) {
                        historyArgs += `, after: "${commitsEndCursor}"`;
                    }
                    historyArgs += `, author: {id: "${userId}"}`;
                    const query = `
                        query {
                            repository(owner: "${owner}", name: "${name}") {
                                url
                                defaultBranchRef {
                                    name
                                    target {
                                        ... on Commit {
                                            history(${historyArgs}) {
                                                pageInfo {
                                                    hasNextPage
                                                    endCursor
                                                }
                                                edges {
                                                    node {
                                                        message
                                                        committedDate
                                                        author {
                                                            user {
                                                                login
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    `;
                    const response = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: HEADERS,
                        body: JSON.stringify({ query: query })
                    });
                     if (!response.ok) {
                        // Check for rate limit in GraphQL response
                        if (response.status === 403 || response.status === 429) {
                             const errorText = await response.text();
                             if (errorText.includes('rate limit') || errorText.includes('API rate limit exceeded')) {
                                  throw new Error(`GraphQL API rate limit exceeded. Status: ${response.status}. Message: ${errorText}`);
                             }
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.errors) {
                        // Check if the error is related to rate limiting
                        const errorMessage = result.errors[0]?.message || 'Unknown GraphQL error';
                        if (errorMessage.includes('rate limit') || errorMessage.includes('API rate limit exceeded')) {
                             throw new Error(`GraphQL API rate limit exceeded. Message: ${errorMessage}`);
                        }
                        throw new Error(errorMessage);
                    }
                    const data = result.data.repository;
                    if (!data || !data.defaultBranchRef || !data.defaultBranchRef.target) {
                        break;
                    }
                    const history = data.defaultBranchRef.target.history;
                    const edges = history.edges;
                    const newCommits = edges
                        .map(edge => ({
                            message: edge.node.message,
                            date: edge.node.committedDate,
                            author: edge.node.author?.user?.login || 'Unknown'
                        }));
                    repoCommits.push(...newCommits);
                    hasCommitsNextPage = history.pageInfo.hasNextPage;
                    commitsEndCursor = history.pageInfo.endCursor;
                    iterations++;
                }
                return repoCommits;
            }
            function displayResults(username, stats, commitsData) {
                document.getElementById('commit-count').textContent = stats.totalCommits.toLocaleString();
                document.getElementById('owned-repo-count').textContent = stats.ownedRepos;
                document.getElementById('contributed-repo-count').textContent = stats.contributedRepos;
                const repoAnalysis = document.getElementById('repo-analysis');
                repoAnalysis.innerHTML = '<h2 style="color: #4ecdc4; margin-bottom: 20px;">Repository Analysis</h2>';
                if (commitsData.length === 0) {
                    repoAnalysis.innerHTML += '<p>No commit data available for analysis.</p>';
                    return;
                }
                repoAnalysis.dataset.allReposData = JSON.stringify(commitsData);
                displayTopRepos(commitsData, repoAnalysis);
                if (commitsData.length > 5) {
                    const showAllButton = document.createElement('button');
                    showAllButton.id = 'show-all-btn';
                    showAllButton.className = 'modal-btn primary-btn';
                    showAllButton.textContent = 'Show Everything';
                    showAllButton.style.display = 'block';
                    showAllButton.style.margin = '20px auto 0 auto';
                    showAllButton.style.width = 'fit-content';
                    showAllButton.dataset.wasVisible = 'true';
                    showAllButton.addEventListener('click', function() {
                        displayAllRepos(commitsData, repoAnalysis);
                        showAllButton.style.display = 'none';
                        showAllButton.dataset.wasVisible = 'false';
                    });
                    repoAnalysis.appendChild(showAllButton);
                    repoAnalysis.dataset.showAllButtonId = showAllButton.id;
                }
            }
            function displayTopRepos(commitsData, containerElement) {
                const title = containerElement.querySelector('h2');
                const showAllBtn = document.getElementById(containerElement.dataset.showAllButtonId);
                containerElement.innerHTML = '';
                if (title) containerElement.appendChild(title);
                const sortedRepos = [...commitsData].sort((a, b) => b.commit_count - a.commit_count);
                const topRepos = sortedRepos.slice(0, 5);
                if (topRepos.length === 0) {
                    containerElement.innerHTML += '<p>No commits found for analysis.</p>';
                    return;
                }
                topRepos.forEach(repo => {
                    const repoDiv = document.createElement('div');
                    repoDiv.className = 'repo-section';
                    const errorMessage = repo.error ? `<div style="color: #ff6b6b; font-size: 0.8rem; margin-top: 5px;">Note: ${repo.error}</div>` : '';
                    repoDiv.innerHTML = `
                        <div class="repo-title">
                            <a href="${repo.url}" class="repo-url" target="_blank">${repo.owner}/${repo.name}</a>
                            <span>${repo.commit_count} commits</span>
                        </div>
                        <div class="commit-list">
                            ${repo.commits.slice(0, 3).map(commit => `
                                <div class="commit-item">
                                    <div class="commit-message">${(commit.message.length > 150 ? commit.message.substring(0, 150) + '...' : commit.message)}</div>
                                    <div class="commit-date">${new Date(commit.date).toLocaleDateString()}</div>
                                </div>
                            `).join('')}
                            ${repo.commits.length > 3 ? `<div class="commit-item">... and ${repo.commits.length - 3} more commits</div>` : ''}
                        </div>
                        ${errorMessage}
                    `;
                    containerElement.appendChild(repoDiv);
                });
                if (showAllBtn) {
                    if (showAllBtn.dataset.wasVisible === 'true') {
                        showAllBtn.style.display = 'block';
                    }
                    containerElement.appendChild(showAllBtn);
                }
            }
            function displayAllRepos(commitsData, containerElement) {
                const title = containerElement.querySelector('h2');
                containerElement.innerHTML = '';
                if (title) containerElement.appendChild(title);
                const sortedRepos = [...commitsData].sort((a, b) => b.commit_count - a.commit_count);
                if (sortedRepos.length === 0) {
                    containerElement.innerHTML += '<p>No commits found for analysis.</p>';
                    return;
                }
                sortedRepos.forEach(repo => {
                    const repoDiv = document.createElement('div');
                    repoDiv.className = 'repo-section';
                    const errorMessage = repo.error ? `<div style="color: #ff6b6b; font-size: 0.8rem; margin-top: 5px;">Note: ${repo.error}</div>` : '';
                    repoDiv.innerHTML = `
                        <div class="repo-title">
                            <a href="${repo.url}" class="repo-url" target="_blank">${repo.owner}/${repo.name}</a>
                            <span>${repo.commit_count} commits</span>
                        </div>
                        <div class="commit-list">
                            ${repo.commits.slice(0, 3).map(commit => `
                                <div class="commit-item">
                                    <div class="commit-message">${(commit.message.length > 150 ? commit.message.substring(0, 150) + '...' : commit.message)}</div>
                                    <div class="commit-date">${new Date(commit.date).toLocaleDateString()}</div>
                                </div>
                            `).join('')}
                            ${repo.commits.length > 3 ? `<div class="commit-item">... and ${repo.commits.length - 3} more commits</div>` : ''}
                        </div>
                        ${errorMessage}
                    `;
                    containerElement.appendChild(repoDiv);
                });
            }
            async function analyzeUser(username, useRestFallback = true) {
                try {
                    const userId = await getUserId(username, useRestFallback);
                    const { ownedRepos, contributedRepos } = await fetchRepositories(username, useRestFallback);
                    const commitsData = await fetchCommitsForAllReposConcurrent(
                        ownedRepos.concat(contributedRepos),
                        userId,
                        username,
                        useRestFallback
                    );
                    updateProgress(95, useRestFallback ? 'Generating analysis (REST)...' : 'Generating analysis...');
                    const totalCommits = commitsData.reduce((sum, repo) => sum + (repo.commit_count || 0), 0);
                    const stats = {
                        totalCommits: totalCommits,
                        ownedRepos: ownedRepos.length,
                        contributedRepos: contributedRepos.length
                    };
                    updateProgress(100, useRestFallback ? 'Analysis complete (REST)!' : 'Analysis complete!');
                    displayResults(username, stats, commitsData);
                } catch (error) {
                    // Re-throw the error to be caught by the outer try/catch in performAnalysis
                    // or directly by the global error handler if not caught there.
                    throw new Error(`Failed to analyze user: ${error.message}`);
                }
            }
            forbiddenOkBtn.addEventListener('click', function() {
                forbiddenModal.classList.remove('active');
            });
            function typeWriterText(text) {
                typewriterText.innerHTML = '';
                let i = 0;
                const speed = 50;
                function typeWriter() {
                    if (i < text.length) {
                        typewriterText.innerHTML += text.charAt(i);
                        i++;
                        setTimeout(typeWriter, speed);
                    } else {
                        setTimeout(() => {
                            robotButtons.style.display = 'flex';
                        }, 1000);
                    }
                }
                typeWriter();
            }
            submitBtn1.addEventListener('click', function() {
                robotModal.classList.remove('active');
                resetForbiddenAttempts();
            });
            submitBtn2.addEventListener('click', function() {
                robotModal.classList.remove('active');
                resetForbiddenAttempts();
            });
            function resetForbiddenAttempts() {
                forbiddenAttempts = 0;
            }
             // --- NEW: Super Error Modal Button Listeners ---
            frownBtn.addEventListener('click', function() {
                hideSuperErrorModal();
                // Do nothing else, just close the modal
            });
            petErrorBtn.addEventListener('click', function() {
                // Store the petting action in localStorage
                localStorage.setItem('bugEmojiPetted', 'true');
                // Update the emoji showcase immediately
                const bugSpan = document.createElement('span');
                bugSpan.textContent = 'üêõ';
                bugSpan.classList.add('bug-emoji'); // Add class for animation
                emojiShowcase.appendChild(bugSpan);
                hideSuperErrorModal();
                // Optional: Add a small confirmation or animation?
            });
            // --- END: Super Error Modal Button Listeners ---
        });
    </script>
</body>
</html>