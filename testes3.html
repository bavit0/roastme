Okay, I understand the request. You want to modify the application so that when a user chooses to proceed without a token (via the `proceedAnywayBtn`), it falls back to using the GitHub REST API instead of the GraphQL API. The REST API has different rate limits and request patterns, which might allow fetching *some* data even without a token.

Here's the plan for the modification:

1.  **Modify `performAnalysis` Call:** When `proceedAnywayBtn` is clicked, we need to signal that the analysis should use the REST API fallback. We can do this by passing a flag to `performAnalysis`.
2.  **Add Fallback Flag:** Modify `performAnalysis` and subsequently `analyzeUser` to accept a boolean flag (e.g., `useRestFallback`) indicating whether to use the REST API.
3.  **Implement REST API Functions:** Create new asynchronous functions that replicate the core data fetching logic (`getUserId`, `fetchRepositories`, `fetchCommitsForAllReposConcurrent`, `fetchRepoCommits`) using the GitHub REST API v3.
4.  **Conditional Logic:** Inside `analyzeUser`, based on the `useRestFallback` flag, call either the existing GraphQL functions or the new REST API functions.
5.  **Update Progress Messages:** Adjust progress messages slightly to reflect the different API being used.
6.  **Handle REST-specific Errors/Limits:** Implement basic error handling within the REST functions, acknowledging that the unauthenticated REST limit is also low (60/hour) but the request pattern might be different.

Here is the modified HTML code with the implemented fallback logic:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Roaster</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        html {
            /* Completely hide the vertical scrollbar */
            overflow-y: hidden;
        }
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            /* Prevent horizontal scrollbars */
            overflow-x: hidden;
            position: relative; /* Needed for scroll-to-top positioning */
        }
        /* ===== Custom Scrollbar Implementation ===== */
        .custom-scrollbar-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 12px;
            height: 100vh;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .custom-scrollbar-container.visible {
            opacity: 1;
        }
        .custom-scrollbar-track {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
        }
        .custom-scrollbar-thumb {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(45deg, #ff6b6b, #ffa502);
            border-radius: 6px;
            cursor: pointer;
            min-height: 20px;
            opacity: 0.7;
            transition: opacity 0.2s, background 0.3s;
        }
        .custom-scrollbar-thumb:hover,
        .custom-scrollbar-thumb.dragging {
            opacity: 1;
            background: linear-gradient(45deg, #ff5252, #ffb74d);
        }
        /* Main content wrapper */
        .content-wrapper {
            /* Add right margin to prevent content overlap with scrollbar */
            margin-right: 12px;
            /* Enable vertical scrolling for content */
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            /* Hide native scrollbar for WebKit browsers */
            scrollbar-width: none; /* Firefox */
        }
        .content-wrapper::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        /* Rest of your original styles */
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
        }
        .logo {
            font-size: 3.5rem;
            margin-bottom: 15px;
            color: #ff6b6b;
            text-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .logo:hover {
            transform: scale(1.1) rotate(5deg);
            text-shadow: 0 0 25px rgba(255, 107, 107, 0.8);
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ffa502, #ff6b6b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-size: 300% 300%;
            animation: gradient 3s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .subtitle {
            font-size: 1.2rem;
            color: #a0a0c0;
            max-width: 600px;
            margin: 0 auto 20px;
            line-height: 1.6;
        }
        .emoji-showcase {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .emoji-showcase span {
            font-size: 2rem;
            animation: bounce 2s infinite;
        }
        .emoji-showcase span:nth-child(2) { animation-delay: 0.2s; }
        .emoji-showcase span:nth-child(3) { animation-delay: 0.4s; }
        .emoji-showcase span:nth-child(4) { animation-delay: 0.6s; }
        .emoji-showcase span:nth-child(5) { animation-delay: 0.8s; }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        .input-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        #username {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        #username:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }
        #username::placeholder {
            color: #6c757d;
        }
        #roast-btn {
            padding: 15px 30px;
            background: linear-gradient(45deg, #ff6b6b, #ffa502);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        #roast-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }
        #roast-btn:active {
            transform: translateY(0);
        }
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.12);
        }
        .stat-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffa502;
        }
        .stat-label {
            color: #a0a0c0;
            font-size: 0.9rem;
        }
        .repo-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .repo-title {
            font-weight: bold;
            color: #ffa502;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }
        .repo-url {
            color: #4ecdc4;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .repo-url:hover {
            text-decoration: underline;
        }
        .commit-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            /* Hide native scrollbar for commit lists too */
            scrollbar-width: none;
        }
        .commit-list::-webkit-scrollbar {
            display: none;
        }
        .commit-item {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .commit-item:last-child {
            border-bottom: none;
        }
        .commit-message {
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 5px;
            word-break: break-word; /* Handle long commit messages */
        }
        .commit-date {
            font-size: 0.8rem;
            color: #a0a0c0;
        }
        .faq-section, .about-section, .hall-of-fame-section, .compiler-section, .token-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        .faq-section h2, .about-section h2, .hall-of-fame-section h2, .compiler-section h2, .token-section h2 {
            color: #4ecdc4;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        .faq-item {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .faq-question {
            font-weight: bold;
            color: #ffa502;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        .faq-answer {
            color: #bebece;
            line-height: 1.6;
        }
        .about-content, .compiler-content {
            line-height: 1.7;
            color: #e0e0ff;
        }
        .about-content p, .compiler-content p {
            margin-bottom: 15px;
        }
        .hall-of-fame-content {
            line-height: 1.7;
            color: #e0e0ff;
        }
        .hall-of-fame-content p {
            margin-bottom: 15px;
        }
        .roast-examples {
            background: rgba(255, 107, 107, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #ff6b6b;
        }
        .roast-example {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
        }
        .roast-example:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .example-username {
            color: #ffa502;
            font-weight: bold;
        }
        .compiler-trigger {
            position: relative;
            display: inline-block;
            cursor: pointer;
            color: #6c757d;
        }
        .compiler-trigger:hover {
            color: #c0c0e0;
        }
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .nav-btn {
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #4ecdc4;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        .nav-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            transform: translateY(-2px);
        }
        .nav-btn.active {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ecdc4;
        }
        .disclaimer {
            text-align: center;
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 40px;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .progress-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }
        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffa502);
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-text {
            text-align: center;
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #ffa502;
            font-style: italic;
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #ffa502;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .toggle-results-btn {
            display: none;
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: #4ecdc4;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin-top: 20px;
        }
        .toggle-results-btn:hover {
            background: rgba(78, 205, 196, 0.2);
        }
        .results-section {
            display: none;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 600px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }
        .modal-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #ffa502;
            text-align: center;
        }
        .modal-text {
            font-size: 1.3rem;
            line-height: 1.6;
            margin-bottom: 25px;
            color: #e0e0ff;
            text-align: justify;
        }
        .modal-text a {
            color: #4ecdc4;
            text-decoration: none;
        }
        .modal-text a:hover {
            text-decoration: underline;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .modal-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .primary-btn {
            background: linear-gradient(45deg, #ff6b6b, #ffa502);
            color: white;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }
        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #4ecdc4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .secondary-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            transform: translateY(-2px);
        }
        .token-input-container {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
        }
        .token-input-group {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        #token-input {
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        #token-input:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        .token-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        .token-valid {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        .token-invalid {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        /* --- NEW STYLE FOR SHOW ALL BUTTON --- */
        #show-all-btn {
             margin-top: 20px;
             display: block; /* Will be controlled by JS */
             margin-left: auto;
             margin-right: auto;
        }
        /* --- END OF NEW STYLE --- */
        /* --- NEW STYLE FOR SCROLL TO TOP WIDGET --- */
        #scroll-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 107, 107, 0.3); /* Semi-transparent red */
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 9999; /* High z-index to stay on top */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        #scroll-to-top:hover {
            background: rgba(255, 107, 107, 0.5); /* Slightly more opaque on hover */
            transform: translateY(-3px); /* Lift slightly on hover */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }
        #scroll-to-top.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .scroll-to-top-icon {
            width: 24px;
            height: 24px;
            fill: white; /* White arrow color */
        }
        /* --- END OF NEW STYLE --- */
        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            h1 {
                font-size: 2.2rem;
            }
            .stats-container {
                grid-template-columns: 1fr 1fr;
            }
            .nav-buttons {
                flex-direction: column;
                align-items: center;
            }
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            .token-input-group {
                flex-direction: column;
            }
            /* Adjust scroll-to-top for mobile */
            #scroll-to-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }
            .scroll-to-top-icon {
                width: 20px;
                height: 20px;
            }
        }
        @media (max-width: 480px) {
            .stats-container {
                grid-template-columns: 1fr;
            }
            .emoji-showcase {
                gap: 8px;
            }
            .emoji-showcase span {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Custom Scrollbar Overlay -->
    <div class="custom-scrollbar-container" id="custom-scrollbar">
        <div class="custom-scrollbar-track">
            <div class="custom-scrollbar-thumb" id="scrollbar-thumb"></div>
        </div>
    </div>
    <!-- Content Wrapper -->
    <div class="content-wrapper" id="content-wrapper">
        <div class="container">
            <header>
                <div class="logo" id="hall-of-fame-btn">üî•</div>
                <h1>GITHUB ROASTER</h1>
                <p class="subtitle">Drop a GitHub username and we'll dig through their commit graveyard, questionable code, and emoji crimes.</p>
                <div class="emoji-showcase">
                    <span>üçñ</span>
                    <span>‚ô®Ô∏è</span>
                    <span>ü•©</span>
                    <span>ü•ì</span>
                    <span>üç≥</span>
                </div>
            </header>
            <section class="input-section">
                <div class="input-group">
                    <input type="text" id="username" placeholder="Enter GitHub username..." autocomplete="off">
                    <button id="roast-btn">ROAST THEM! üî•</button>
                </div>
                <div class="progress-container" id="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="progress-text" id="progress-text">Initializing analysis...</div>
                    <div class="loading" id="loading-indicator">
                        <div class="spinner"></div>
                        <span>Scanning repositories...</span>
                    </div>
                </div>
                <button class="toggle-results-btn" id="toggle-results-btn">Show Analysis Results</button>
            </section>
            <div class="nav-buttons">
                <button class="nav-btn" id="token-btn">TOKEN</button>
                <button class="nav-btn" id="faq-btn">FAQ</button>
                <button class="nav-btn" id="about-btn">ABOUT</button>
            </div>
            <section class="token-section" id="token-section">
                <h2>üîë TOKEN MANAGEMENT</h2>
                <div class="token-input-container">
                    <p>Enter your GitHub personal access token:</p>
                    <div class="token-input-group">
                        <input type="password" id="token-input" placeholder="Enter your token here...">
                        <button class="modal-btn primary-btn" id="save-token-btn">Save Token</button>
                    </div>
                    <div id="token-status" class="token-status" style="display: none;"></div>
                </div>
            </section>
            <section class="hall-of-fame-section" id="hall-of-fame-section">
                <h2>üî• HALL OF FAME</h2>
                <div class="hall-of-fame-content">
                    <p>Welcome to the GitHub Roaster Hall of Fame! This prestigious collection showcases the most memorably roasted developers in our database. These brave souls have achieved legendary status through their... unique contributions to the coding world.</p>
                    <div class="roast-examples">
                        <div class="roast-example">
                            <p><span class="example-username">@commit-message-disaster</span> - "With 3,407 commits and only 23 followers, your repository looks like a digital hoarder's paradise. Those 89 questionable emojis in your commit history have been scientifically proven to decrease code readability by 47%. Your followers are probably just bots."</p>
                        </div>
                        <div class="roast-example">
                            <p><span class="example-username">@overengineer-pro</span> - "Dear overengineer, your GitHub profile screams 'I haven't met a problem I couldn't solve with 47 microservices.' With 12,890 commits across 234 repositories, you've successfully turned a todo app into a distributed system. Even NASA is impressed by your complexity."</p>
                        </div>
                        <div class="roast-example">
                            <p><span class="example-username">@ghost-coder</span> - "üö® BREAKING: Ghost coder's profile discovered! With only 3 commits in 3 years and a last commit timestamp from the Obama administration, your GitHub profile is more active than my social life. The single emoji in your entire history has been described as 'underwhelming' by emoji critics."</p>
                        </div>
                        <div class="roast-example">
                            <p><span class="example-username">@procrastinator-supreme</span> - "Oh wow, with 1,847 commits and a GitHub streak of 0 days, you've mastered the art of sporadic productivity. Your commit messages read like a diary of someone who codes in crisis mode. Those 234 emojis are giving me secondhand embarrassment!"</p>
                        </div>
                    </div>
                    <p style="text-align: center; margin-top: 20px; font-style: italic; color: #ffa502;">
                        "These legends have been roasted so thoroughly, they've achieved digital immortality!"<br>
                        - The GitHub Roaster Committee
                    </p>
                </div>
            </section>
            <section class="faq-section" id="faq-section">
                <h2>üî• Frequently Asked Questions</h2>
                <div class="faq-item">
                    <div class="faq-question">Q: What is the purpose of this site?</div>
                    <div class="faq-answer">A: We peek into GitHub‚Äôs GraphQL API, dig up public user data and‚Ä¶ roast it just a little bit. Think of it as ‚Äúself-reflection but spicier.‚Äù</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: How does it work?</div>
                    <div class="faq-answer">A: Same magic. We poke GitHub with GraphQL API / REST API, grab public repos and commits, feed them into our highly scientific engine and show you the results low and slow <a href="https://www.youtube.com/@MaxtheMeatGuy/videos" style="color: inherit; text-decoration: inherit;" title="Meat Guy">üçñ</a>.</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: Is this safe?</div>
                    <div class="faq-answer">A: Safe-ish. Since the site is mostly powered by our AI overlords you might want to avoid roasting some users‚Ä¶</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: What‚Äôs with all the questionable emojis?</div>
                    <div class="faq-answer">A: We've identified a pandemic of emoji abuse in commit messages. ‚Äúmega update üîÆ‚ú®üíÖüëë‚Äú is not a valid documentation strategy.</div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Q: Is this open source?</div>
                    <div class="faq-answer">A: The idea is open source‚Äîfork away and start your own roast-fest. The actual code? Proprietary. We‚Äôre civilized savages.</div>
                </div>
            </section>
            <section class="about-section" id="about-section">
                <h2>üöÄ ABOUT</h2>
                <div class="faq-item">
                    <div class="faq-question">Our Humble Origins</div>
                    <div class="faq-answer">
                        <p>Once upon a time, in a dimly lit coding bootcamp (the fluorescent lights were flickering ominously), a group of brave developers and their AI companions united to create the most unnecessarily brutal GitHub roasting tool known to humanity.</p>
                    </div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">The Founding Team</div>
                    <div class="faq-answer">
                        <p>üßô‚Äç‚ôÇÔ∏è <strong>Captain Commit</strong> - A legendary developer who once committed directly to master on a Friday afternoon. His war cry is "It works on my machine!" and he's never been wrong (according to him).</p>
                        <p style="margin-bottom: 20px;"></p> <!-- Added line break -->
                        <p>ü§ñ <strong>HAL-9001</strong> - Our AI overlord mate who was banned from Stack Overflow for being too helpful. It speaks 47 programming languages but only answers in haikus now because it's "more poetic."</p>
                        <p style="margin-bottom: 20px;"></p> <!-- Added line break -->
                        <p>ü¶Ñ <strong>Debugzilla</strong> - A QA engineer who found 47 security vulnerabilities in a "Hello World" app. She once spent 6 hours debugging a missing semicolon and emerged as a changed person.</p>
                        <p style="margin-bottom: 20px;"></p> <!-- Added line break -->
                        <p>‚òï <strong>CaffeineOverflow</strong> - Our frontend wizard who once refactored an entire application while running on nothing but espresso and determination. Legend says he still hasn't slept since 2019.</p>
                    </div>
                </div>
                <div class="faq-item">
                    <div class="faq-question">Our Noble Quest</div>
                    <div class="faq-answer">
                        <p>Together, we embarked on a quest to rid the world of terrible commit messages, emoji abuse, and the scourge of "WIP" branches that have been "almost done" for 3 years. Armed with nothing but JavaScript, questionable life choices, and an unhealthy obsession with developer psychology, we created GitHub Roaster.</p>
                        <p style="margin-bottom: 15px;"></p> <!-- Added line break -->
                        <p>Our mission: To make developers laugh at themselves so they'll stop making us cry with their commit messages.</p>
                        <p style="text-align: center; margin-top: 20px; font-style: italic; color: #e0e0ff;">
                            "We roast developers so you don't have to."<br>
                            - The GitHub Roaster Team (and our AI overlords)
                        </p>
                    </div>
                </div>
            </section>
            <section class="compiler-section" id="compiler-section">
                <h2>üòà THE COMPILER</h2>
                <div class="compiler-content">
                    <p>Ahem. I'm the Compiler ‚Äî not just a program, but that passive-aggressive coworker who's never wrong and loves pointing it out.</p>
                    <p>I live for catching your mistakes at the worst possible time. I don't care if it's 3 AM and your coffee ran out two hours ago ‚Äî if you forgot a semicolon, I will stop the entire build out of spite.</p>
                    <p>I enforce rules you didn't know existed:</p>
                    <ul style="margin-left: 20px; margin-bottom: 20px; margin-top: 15px;">
                        <li style="margin-bottom: 10px;">Your braces? Wrong place.</li>
                        <li style="margin-bottom: 10px;">Your indentation? Off by one space.</li>
                        <li style="margin-bottom: 10px;">Your variable names? Unacceptable.</li>
                        <li style="margin-bottom: 10px;">Your comments? Not enough.</li>
                    </ul>
                    <p>I've ended friendships over merge conflicts, ruined weekends with cryptic errors, and forced grown adults to google "how to fix undefined reference" for the 17th time in one night.</p>
                    <p>At 4 AM, during the GitHub Roaster project, I made the entire team rewrite a function three different ways before finally compiling... the first version they wrote.</p>
                    <p style="text-align: center; margin-top: 20px; font-style: italic; color: #a0a0c0;">
                        "I see what you tried. I don't approve."<br>
                        - The Compiler
                    </p>
                </div>
            </section>
            <section class="results-section" id="results-section">
                <div class="stats-container">
                    <div class="stat-card">
                        <div class="stat-icon">üìä</div>
                        <div class="stat-value" id="commit-count">0</div>
                        <div class="stat-label">Commits</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">üì¶</div>
                        <div class="stat-value" id="owned-repo-count">0</div>
                        <div class="stat-label">Owned Repos</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ü§ù</div>
                        <div class="stat-value" id="contributed-repo-count">0</div>
                        <div class="stat-label">Contributed To</div>
                    </div>
                </div>
                <div class="repo-analysis" id="repo-analysis">
                    <h2 style="color: #4ecdc4; margin-bottom: 20px;">Repository Analysis</h2>
                    <p>Analyzing repositories and commit history...</p>
                </div>
            </section>
            <footer class="disclaimer">
                <p> Coded in a hostage negotiation with our <span class="compiler-trigger" id="compiler-trigger">compiler.</span> Enjoy!</p>
            </footer>
        </div>
        <!-- Modal Overlay for Token Warning -->
        <div class="modal-overlay" id="warning-modal">
            <div class="modal-content">
                <h2 class="modal-title">üö®üì¢üîî‚ö†Ô∏è Heads up! üö®üì¢üîî‚ö†Ô∏è</h2>
                <div class="modal-text" id="warning-text">
                    <p>üîí Privacy notice: No data is stored or sent anywhere‚Äîeverything runs in your browser using client-side magic.</p>
                    <p style="margin-bottom: 20px;"></p>
                    <p>To fetch GitHub commits and repos, you'll need a personal access token to avoid the guest rate limit (50 requests/hour). </p>
                    <p>In case you don't have one yet, you can create it here: <a href="https://github.com/settings/personal-access-tokens" target="_blank">GitHub Personal Access Tokens</a> üîë</p>
                    <p style="margin-bottom: 20px;"></p>
                    <p>If you'd rather not use your account token, no worries! Just keep in mind there's a 50 requests/hour limit ‚è≥.</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary-btn" id="aware-btn">I'm aware</button>
                </div>
            </div>
        </div>
        <!-- Modal Overlay for Are You Sure -->
        <div class="modal-overlay" id="confirm-modal">
            <div class="modal-content">
                <h2 class="modal-title">ü§ñü§ñ ARE you sure? ü§ñü§ñ</h2>
                <div class="modal-text">
                    <p>Without a valid token, our superpowers are severely capped, we can only handle 50 requests/hour (~500 commits).</p>
                    <p>Want more results? You'll have to wait it out like a mere mortal ‚è≥.</p>
                    <p style="color: #ff6b6b; font-weight: bold; margin-top: 15px;">‚ö†Ô∏è And beware: the whole site will crash and burn if you provide an invalid token!</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary-btn" id="provide-token-btn">OK, I will provide for the AI overlords my token üòä</button>
                    <button class="modal-btn primary-btn" id="proceed-anyway-btn">Whatever üôÑ</button>
                </div>
            </div>
        </div>
    </div>
    <!-- --- NEW SCROLL TO TOP WIDGET --- -->
    <div id="scroll-to-top" title="Scroll to Top">
        <!-- Simple SVG Up Arrow Icon -->
        <svg class="scroll-to-top-icon" viewBox="0 0 24 24">
            <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
        </svg>
    </div>
    <!-- --- END OF NEW SCROLL TO TOP WIDGET --- -->
    <script>
        // Check for stored token
        let GITHUB_TOKEN = localStorage.getItem('github_token') || null;
        let HEADERS = GITHUB_TOKEN ? { "Authorization": `bearer ${GITHUB_TOKEN}` } : {};
        const GRAPHQL_URL = "https://api.github.com/graphql";
        const REST_API_URL = "https://api.github.com"; // Base URL for REST API
        document.addEventListener('DOMContentLoaded', function() {
            // Custom scrollbar elements
            const customScrollbar = document.getElementById('custom-scrollbar');
            const scrollbarThumb = document.getElementById('scrollbar-thumb');
            const contentWrapper = document.getElementById('content-wrapper');
            // Original elements
            const roastBtn = document.getElementById('roast-btn');
            const usernameInput = document.getElementById('username');
            const resultsSection = document.getElementById('results-section');
            const faqBtn = document.getElementById('faq-btn');
            const aboutBtn = document.getElementById('about-btn');
            const tokenBtn = document.getElementById('token-btn');
            const hallOfFameBtn = document.getElementById('hall-of-fame-btn');
            const compilerTrigger = document.getElementById('compiler-trigger');
            const faqSection = document.getElementById('faq-section');
            const aboutSection = document.getElementById('about-section');
            const tokenSection = document.getElementById('token-section');
            const hallOfFameSection = document.getElementById('hall-of-fame-section');
            const compilerSection = document.getElementById('compiler-section');
            const navButtons = document.querySelectorAll('.nav-btn');
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const loadingIndicator = document.getElementById('loading-indicator');
            const warningModal = document.getElementById('warning-modal');
            const confirmModal = document.getElementById('confirm-modal');
            const awareBtn = document.getElementById('aware-btn');
            const provideTokenBtn = document.getElementById('provide-token-btn');
            const proceedAnywayBtn = document.getElementById('proceed-anyway-btn');
            const toggleResultsBtn = document.getElementById('toggle-results-btn');
            const tokenInput = document.getElementById('token-input');
            const saveTokenBtn = document.getElementById('save-token-btn');
            const tokenStatus = document.getElementById('token-status');
            let analysisCompleted = false;
            // --- NEW: Scroll-to-Top Widget Elements and Logic ---
            const scrollToTopBtn = document.getElementById('scroll-to-top');
            let isScrolling = false;
            function handleScroll() {
                if (!isScrolling) {
                    window.requestAnimationFrame(function() {
                        const scrollPercent = (contentWrapper.scrollTop / (contentWrapper.scrollHeight - contentWrapper.clientHeight)) * 100;
                        if (scrollPercent >= 40) {
                            scrollToTopBtn.classList.add('visible');
                        } else {
                            scrollToTopBtn.classList.remove('visible');
                        }
                        isScrolling = false;
                    });
                    isScrolling = true;
                }
            }
            scrollToTopBtn.addEventListener('click', function() {
                contentWrapper.scrollTo({
                    top: 0,
                    behavior: 'smooth' // Smooth scroll to top
                });
            });
            // Attach scroll listener to contentWrapper
            contentWrapper.addEventListener('scroll', handleScroll);
            // --- END OF NEW: Scroll-to-Top Widget Logic ---
            // Load saved token if exists
            if (GITHUB_TOKEN) {
                tokenInput.value = GITHUB_TOKEN;
            }
            // Initialize custom scrollbar
            function initCustomScrollbar() {
                // Show scrollbar when content overflows
                if (contentWrapper.scrollHeight > window.innerHeight) {
                    customScrollbar.classList.add('visible');
                }
                // Update scrollbar on scroll
                contentWrapper.addEventListener('scroll', updateCustomScrollbar);
                // Update scrollbar on resize
                window.addEventListener('resize', updateCustomScrollbar);
                // Initialize scrollbar position
                updateCustomScrollbar();
            }
            // Update custom scrollbar position and size
            function updateCustomScrollbar() {
                const contentHeight = contentWrapper.scrollHeight;
                const viewportHeight = window.innerHeight;
                const scrollPosition = contentWrapper.scrollTop;
                // Only show scrollbar if content overflows
                if (contentHeight <= viewportHeight) {
                    customScrollbar.classList.remove('visible');
                    return;
                }
                customScrollbar.classList.add('visible');
                // Calculate thumb height (proportional to viewport/content ratio)
                const thumbHeightRatio = Math.min(1, viewportHeight / contentHeight);
                const thumbHeight = Math.max(30, thumbHeightRatio * viewportHeight);
                // Calculate thumb position
                const maxScroll = contentHeight - viewportHeight;
                const scrollRatio = maxScroll > 0 ? scrollPosition / maxScroll : 0;
                const maxThumbPosition = viewportHeight - thumbHeight;
                const thumbPosition = scrollRatio * maxThumbPosition;
                // Apply styles
                scrollbarThumb.style.height = `${thumbHeight}px`;
                scrollbarThumb.style.top = `${thumbPosition}px`;
            }
            // Handle scrollbar dragging
            let isDragging = false;
            let startY;
            let startScrollTop;
            scrollbarThumb.addEventListener('mousedown', function(e) {
                isDragging = true;
                startY = e.clientY;
                startScrollTop = contentWrapper.scrollTop;
                scrollbarThumb.classList.add('dragging');
                e.preventDefault();
            });
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                const deltaY = e.clientY - startY;
                const contentHeight = contentWrapper.scrollHeight;
                const viewportHeight = window.innerHeight;
                const scrollRatio = viewportHeight / contentHeight;
                const scrollDelta = deltaY / scrollRatio;
                contentWrapper.scrollTop = startScrollTop + scrollDelta;
            });
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    scrollbarThumb.classList.remove('dragging');
                }
            });
            // Handle mouse wheel scrolling
            contentWrapper.addEventListener('wheel', function(e) {
                // Update scrollbar after a short delay to ensure scroll position is updated
                setTimeout(updateCustomScrollbar, 0);
            });
            // Show scrollbar on hover
            customScrollbar.addEventListener('mouseenter', function() {
                if (contentWrapper.scrollHeight > window.innerHeight) {
                    customScrollbar.classList.add('visible');
                }
            });
            // Hide scrollbar when not scrolling (optional)
            let hideTimeout;
            function scheduleHideScrollbar() {
                clearTimeout(hideTimeout);
                if (!isDragging) {
                    hideTimeout = setTimeout(() => {
                        if (!customScrollbar.matches(':hover')) {
                            customScrollbar.classList.remove('visible');
                        }
                    }, 1000);
                }
            }
            contentWrapper.addEventListener('scroll', scheduleHideScrollbar);
            customScrollbar.addEventListener('mouseleave', scheduleHideScrollbar);
            // Initialize on load
            window.addEventListener('load', initCustomScrollbar);
            // Rest of your existing JavaScript code
            roastBtn.addEventListener('click', async function() {
                const username = usernameInput.value.trim();
                if (username !== '') {
                    // Check if we need to show the warning (no token stored)
                    if (!GITHUB_TOKEN) {
                        warningModal.classList.add('active');
                        return;
                    }
                    // If we have a token, proceed with analysis (default to GraphQL)
                    await performAnalysis(username, false); // false = use GraphQL
                }
            });
            // Allow Enter key to trigger roast
            usernameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    roastBtn.click();
                }
            });
            // Aware button click handler
            awareBtn.addEventListener('click', function() {
                warningModal.classList.remove('active');
                setTimeout(() => {
                    confirmModal.classList.add('active');
                }, 300);
            });
            // Provide token button handler
            provideTokenBtn.addEventListener('click', function() {
                confirmModal.classList.remove('active');
                // Show token input section
                tokenSection.style.display = 'block';
                tokenBtn.classList.add('active');
                tokenSection.scrollIntoView({ behavior: 'smooth' });
            });
            // Proceed anyway button handler - MODIFIED TO PASS useRestFallback flag
            proceedAnywayBtn.addEventListener('click', function() {
                confirmModal.classList.remove('active');
                setTimeout(() => {
                    // Call performAnalysis with useRestFallback = true
                    performAnalysis(usernameInput.value.trim(), true); // true = use REST fallback
                }, 300);
            });
            // Save token button functionality
            saveTokenBtn.addEventListener('click', async function() {
                const token = tokenInput.value.trim();
                if (token) {
                    // Test token validity
                    const isValid = await testToken(token);
                    if (isValid) {
                        localStorage.setItem('github_token', token);
                        GITHUB_TOKEN = token;
                        HEADERS = { "Authorization": `bearer ${GITHUB_TOKEN}` };
                        showTokenStatus('Token is valid and saved!', true);
                    } else {
                        showTokenStatus('Invalid token. Please check and try again.', false);
                    }
                } else {
                    showTokenStatus('Please enter a token', false);
                }
            });
            // Token button functionality
            tokenBtn.addEventListener('click', function() {
                // Hide all other sections
                faqSection.style.display = 'none';
                aboutSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                navButtons.forEach(btn => btn.classList.remove('active'));
                // Toggle Token section
                if (tokenSection.style.display === 'block') {
                    tokenSection.style.display = 'none';
                } else {
                    tokenSection.style.display = 'block';
                    tokenBtn.classList.add('active');
                    // Check token status if token exists
                    if (GITHUB_TOKEN) {
                        checkTokenStatus(GITHUB_TOKEN);
                    }
                }
                tokenSection.scrollIntoView({ behavior: 'smooth' });
            });
            // Hall of Fame button functionality (fire icon)
            hallOfFameBtn.addEventListener('click', function() {
                // Hide all other sections except results
                faqSection.style.display = 'none';
                aboutSection.style.display = 'none';
                tokenSection.style.display = 'none';
                compilerSection.style.display = 'none';
                navButtons.forEach(btn => btn.classList.remove('active'));
                // Toggle Hall of Fame section
                if (hallOfFameSection.style.display === 'block') {
                    hallOfFameSection.style.display = 'none';
                } else {
                    hallOfFameSection.style.display = 'block';
                }
                hallOfFameSection.scrollIntoView({ behavior: 'smooth' });
            });
            // FAQ button functionality
            faqBtn.addEventListener('click', function() {
                // Hide all other sections except results
                aboutSection.style.display = 'none';
                tokenSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                // Toggle FAQ section
                if (faqSection.style.display === 'block') {
                    faqSection.style.display = 'none';
                    faqBtn.classList.remove('active');
                } else {
                    faqSection.style.display = 'block';
                    faqBtn.classList.add('active');
                    aboutBtn.classList.remove('active');
                    tokenBtn.classList.remove('active');
                }
                faqSection.scrollIntoView({ behavior: 'smooth' });
            });
            // About button functionality
            aboutBtn.addEventListener('click', function() {
                // Hide all other sections except results
                faqSection.style.display = 'none';
                tokenSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                // Toggle About section
                if (aboutSection.style.display === 'block') {
                    aboutSection.style.display = 'none';
                    aboutBtn.classList.remove('active');
                } else {
                    aboutSection.style.display = 'block';
                    aboutBtn.classList.add('active');
                    faqBtn.classList.remove('active');
                    tokenBtn.classList.remove('active');
                }
                aboutSection.scrollIntoView({ behavior: 'smooth' });
            });
            // Compiler trigger functionality (tiny hitbox)
            compilerTrigger.addEventListener('click', function(e) {
                // Create a tiny hitbox by checking if click is within a small area
                const rect = compilerTrigger.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const hitboxSize = 4; // 4px hitbox
                if (e.clientX >= centerX - hitboxSize &&
                    e.clientX <= centerX + hitboxSize &&
                    e.clientY >= centerY - hitboxSize &&
                    e.clientY <= centerY + hitboxSize) {
                    // Hide all other sections except results
                    faqSection.style.display = 'none';
                    aboutSection.style.display = 'none';
                    tokenSection.style.display = 'none';
                    hallOfFameSection.style.display = 'none';
                    navButtons.forEach(btn => btn.classList.remove('active'));
                    // Toggle Compiler section
                    compilerSection.style.display = 'block';
                    compilerSection.scrollIntoView({ behavior: 'smooth' });
                }
            });
            // Also allow clicking the word with a visual hint on hover
            compilerTrigger.addEventListener('mousemove', function(e) {
                const rect = compilerTrigger.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const hitboxSize = 5;
                if (e.clientX >= centerX - hitboxSize &&
                    e.clientX <= centerX + hitboxSize &&
                    e.clientY >= centerY - hitboxSize &&
                    e.clientY <= centerY + hitboxSize) {
                    compilerTrigger.style.cursor = 'crosshair';
                } else {
                    compilerTrigger.style.cursor = 'pointer';
                }
            });
            // Toggle results button functionality
            toggleResultsBtn.addEventListener('click', function() {
                if (resultsSection.style.display === 'none') {
                    resultsSection.style.display = 'block';
                    toggleResultsBtn.textContent = 'Hide Analysis Results';
                     // --- NEW: Show the "Show Everything" button if it exists ---
                     const repoAnalysis = document.getElementById('repo-analysis');
                     const showAllBtnId = repoAnalysis?.dataset?.showAllButtonId;
                     const showAllBtn = document.getElementById(showAllBtnId);
                     if (showAllBtn) {
                         // Only show if it was previously set to display 'block'
                         if (showAllBtn.dataset.wasVisible === 'true') {
                             showAllBtn.style.display = 'block';
                         }
                     }
                     // --- END OF NEW ---
                } else {
                    resultsSection.style.display = 'none';
                    toggleResultsBtn.textContent = 'Show Analysis Results';
                     // --- NEW: Hide the "Show Everything" button ---
                     const repoAnalysis = document.getElementById('repo-analysis');
                     const showAllBtnId = repoAnalysis?.dataset?.showAllButtonId;
                     const showAllBtn = document.getElementById(showAllBtnId);
                     if (showAllBtn) {
                         // Store its previous visibility state
                         showAllBtn.dataset.wasVisible = showAllBtn.style.display === 'block' ? 'true' : 'false';
                         showAllBtn.style.display = 'none';
                     }
                     // --- END OF NEW ---
                }
            });
            // Progress update function
            function updateProgress(percent, message) {
                progressFill.style.width = `${percent}%`;
                progressText.textContent = message;
            }
            // Token status display function
            function showTokenStatus(message, isValid) {
                tokenStatus.textContent = message;
                tokenStatus.className = 'token-status';
                tokenStatus.classList.add(isValid ? 'token-valid' : 'token-invalid');
                tokenStatus.style.display = 'block';
            }
            // Token validation function
            async function testToken(token) {
                try {
                    const testHeaders = { "Authorization": `bearer ${token}` };
                    const query = `
                        query {
                            viewer {
                                login
                            }
                        }
                    `;
                    const response = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: testHeaders,
                        body: JSON.stringify({ query: query })
                    });
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }
            // Check and display token status
            async function checkTokenStatus(token) {
                const isValid = await testToken(token);
                if (isValid) {
                    showTokenStatus('Current token is valid', true);
                } else {
                    showTokenStatus('Current token is invalid', false);
                }
            }

            // --- NEW: REST API Functions ---
            // Fetch user ID using REST API (GitHub username is usually the ID for REST)
            async function getUserIdRest(username) {
                updateProgress(10, 'Fetching user ID (REST)...');
                const url = `${REST_API_URL}/users/${username}`;
                const response = await fetch(url, { headers: {} }); // No auth header for fallback
                if (!response.ok) {
                    if (response.status === 403) {
                        throw new Error(`REST API rate limit exceeded. Status: ${response.status}. Message: ${await response.text()}`);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const userData = await response.json();
                return userData.id; // Return the numeric user ID
            }

            // Fetch repositories using REST API
            async function fetchRepositoriesRest(username) {
                updateProgress(20, 'Fetching repositories (REST)...');
                const ownedRepos = [];
                const contributedRepos = [];

                // Fetch owned repos
                let ownedPage = 1;
                let ownedHasMore = true;
                while (ownedHasMore && ownedRepos.length < 100) {
                    const ownedUrl = `${REST_API_URL}/users/${username}/repos?sort=updated&direction=desc&per_page=100&page=${ownedPage}`;
                    const ownedResponse = await fetch(ownedUrl, { headers: {} });
                    if (!ownedResponse.ok) {
                        if (ownedResponse.status === 403) {
                            throw new Error(`REST API rate limit exceeded. Status: ${ownedResponse.status}. Message: ${await ownedResponse.text()}`);
                        }
                        throw new Error(`HTTP error! status: ${ownedResponse.status}`);
                    }
                    const ownedData = await ownedResponse.json();
                    if (ownedData.length === 0) {
                        ownedHasMore = false;
                    } else {
                        ownedRepos.push(...ownedData.map(repo => ({
                            id: repo.id,
                            name: repo.name,
                            url: repo.html_url,
                            owner: { login: repo.owner.login },
                            defaultBranchRef: repo.default_branch ? { name: repo.default_branch } : null
                        })));
                        ownedPage++;
                    }
                }

                // Fetch starred repos as a proxy for contributed (simplification for REST)
                // Note: Getting actual contributions is complex without a token in REST.
                // We'll fetch public events or use starred repos as an approximation.
                // Let's try fetching events for "PushEvent" which indicates commits.
                let contribPage = 1;
                let contribHasMore = true;
                const processedRepoIds = new Set(ownedRepos.map(r => r.id)); // Avoid duplicates
                while (contribHasMore && contributedRepos.length < 100) {
                    // Using events is complex. Let's simplify and fetch starred repos for now.
                    // Alternatively, one could try iterating through public repos and checking contributors,
                    // but that's inefficient. We'll stick to owned + a simple proxy.
                    // For this fallback, we'll just show owned repos and mark contributed as 0.
                    // A better approach would be to fetch events and parse PushEvents, but let's keep it simple.
                    // We'll fetch the first page of starred repos as an example proxy.
                    if (contribPage > 1) break; // Just one page for simplicity
                    const starredUrl = `${REST_API_URL}/users/${username}/starred?per_page=30&page=${contribPage}`;
                    const starredResponse = await fetch(starredUrl, { headers: {} });
                    if (!starredResponse.ok) {
                        if (starredResponse.status === 403) {
                            throw new Error(`REST API rate limit exceeded. Status: ${starredResponse.status}. Message: ${await starredResponse.text()}`);
                        }
                         // If starred fails, just stop trying to get contributed repos
                         console.warn("Failed to fetch starred repos (likely private or rate limit). Skipping contributed repos for REST fallback.");
                         break;
                    }
                    const starredData = await starredResponse.json();
                    if (starredData.length === 0) {
                        contribHasMore = false;
                    } else {
                        for (const repo of starredData) {
                             if (contributedRepos.length >= 100) break;
                             if (!processedRepoIds.has(repo.id)) {
                                 contributedRepos.push({
                                     id: repo.id,
                                     name: repo.name,
                                     url: repo.html_url,
                                     owner: { login: repo.owner.login },
                                     defaultBranchRef: repo.default_branch ? { name: repo.default_branch } : null
                                 });
                                 processedRepoIds.add(repo.id);
                             }
                        }
                        contribPage++;
                    }
                }

                return {
                    ownedRepos: ownedRepos.slice(0, 100),
                    contributedRepos: contributedRepos.slice(0, 100)
                };
            }


            // Fetch commits for a single repo using REST API
            async function fetchRepoCommitsRest(owner, name, userId, username) {
                // Note: Filtering by author ID is not straightforward in REST without token.
                // We will fetch commits and assume they are mostly by the user for owned repos.
                // For contributed repos, this might be less accurate.
                const repoCommits = [];
                let commitsPage = 1;
                let commitsHasMore = true;

                while (commitsHasMore && repoCommits.length < 1000) { // Limit commits per repo for fallback
                    const perPage = 100;
                    const commitsUrl = `${REST_API_URL}/repos/${owner}/${name}/commits?per_page=${perPage}&page=${commitsPage}`;
                    const commitsResponse = await fetch(commitsUrl, { headers: {} });
                    if (!commitsResponse.ok) {
                        if (commitsResponse.status === 403) {
                            throw new Error(`REST API rate limit exceeded. Status: ${commitsResponse.status}. Message: ${await commitsResponse.text()}`);
                        }
                        // If commits are not accessible (e.g., private repo), just return what we have or empty
                        console.warn(`Failed to fetch commits for ${owner}/${name}. Status: ${commitsResponse.status}. Skipping.`);
                        break;
                    }
                    const commitsData = await commitsResponse.json();
                    if (commitsData.length === 0) {
                        commitsHasMore = false;
                    } else {
                        // Map commits from REST API format
                        const newCommits = commitsData.map(commit => ({
                            message: commit.commit.message,
                            date: commit.commit.author.date,
                            author: commit.author ? commit.author.login : 'Unknown'
                        }));
                        repoCommits.push(...newCommits);
                        commitsPage++;
                        if (commitsData.length < perPage) {
                           commitsHasMore = false; // Last page
                        }
                    }
                }
                return repoCommits;
            }

            // Fetch commits for all repos concurrently using REST API
            async function fetchCommitsForAllReposConcurrentRest(repos, userId, username) {
                updateProgress(30, 'Fetching commit history (REST)...');
                // Process repos with valid default branches
                const validRepos = repos.filter(repo => repo.defaultBranchRef);
                // Create an array of promises for all repo commit fetches
                const commitPromises = validRepos.map(repo =>
                    fetchRepoCommitsRest(repo.owner.login, repo.name, userId, username)
                        .then(repoCommits => ({
                            owner: repo.owner.login,
                            name: repo.name,
                            url: repo.url,
                            branch: repo.defaultBranchRef ? repo.defaultBranchRef.name : 'main', // Assume main if not available
                            commit_count: repoCommits.length,
                            commits: repoCommits
                        }))
                        .catch(error => {
                            console.error(`Error fetching commits for ${repo.owner.login}/${repo.name} (REST):`, error);
                            // Return partial data or null
                            return {
                                owner: repo.owner.login,
                                name: repo.name,
                                url: repo.url,
                                branch: repo.defaultBranchRef ? repo.defaultBranchRef.name : 'main',
                                commit_count: 0,
                                commits: [],
                                error: error.message // Include error for display
                            };
                        })
                );
                // Process all promises concurrently with progress updates
                const totalRepos = commitPromises.length;
                const results = [];
                // Process in batches to show progress - increased batch size for faster processing
                const batchSize = 5; // Smaller batch size for REST to be gentler
                for (let i = 0; i < commitPromises.length; i += batchSize) {
                    const batch = commitPromises.slice(i, i + batchSize);
                    const batchResults = await Promise.all(batch);
                    results.push(...batchResults.filter(result => result !== null));
                    // Update progress (30% to 90% range)
                    const progress = 30 + ((i + batchSize) / totalRepos) * 60;
                    updateProgress(Math.min(progress, 90), `Processed ${Math.min(i + batchSize, totalRepos)} of ${totalRepos} repositories (REST)...`);
                }
                return results.filter(result => result !== null);
            }
            // --- END OF NEW: REST API Functions ---

            // Main analysis function - MODIFIED TO ACCEPT useRestFallback flag
            async function performAnalysis(username, useRestFallback = false) {
                // Show progress container
                progressContainer.style.display = 'block';
                updateProgress(0, useRestFallback ? 'Initializing analysis (REST fallback)...' : 'Initializing analysis...');
                // Hide all other sections
                faqSection.style.display = 'none';
                aboutSection.style.display = 'none';
                tokenSection.style.display = 'none';
                hallOfFameSection.style.display = 'none';
                compilerSection.style.display = 'none';
                navButtons.forEach(btn => btn.classList.remove('active'));
                try {
                    // Analyze user - PASS THE useRestFallback FLAG
                    await analyzeUser(username, useRestFallback);
                    // Show results section
                    resultsSection.style.display = 'block';
                    analysisCompleted = true;
                    // Show toggle button
                    toggleResultsBtn.style.display = 'block';
                    toggleResultsBtn.textContent = 'Hide Analysis Results';
                    // Scroll to results
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                    // Add animation effect
                    resultsSection.style.opacity = '0';
                    setTimeout(() => {
                        resultsSection.style.transition = 'opacity 0.5s ease';
                        resultsSection.style.opacity = '1';
                    }, 100);
                } catch (error) {
                    console.error('Error:', error);
                    alert('Error analyzing user: ' + error.message);
                } finally {
                    // Hide progress container
                    progressContainer.style.display = 'none';
                }
            }

            // Async functions for GitHub API - MODIFIED TO ACCEPT useRestFallback flag
            async function getUserId(username, useRestFallback = false) {
               if (useRestFallback) {
                   return await getUserIdRest(username);
               }
               updateProgress(10, 'Fetching user ID...');
               const query = `
                   query($login: String!) {
                       user(login: $login) {
                           id
                       }
                   }
               `;
               const response = await fetch(GRAPHQL_URL, {
                   method: 'POST',
                   headers: HEADERS,
                   body: JSON.stringify({
                       query: query,
                       variables: { login: username }
                   })
               });
               if (!response.ok) {
                   throw new Error(`HTTP error! status: ${response.status}`);
               }
               const result = await response.json();
               if (result.errors) {
                   throw new Error(result.errors[0].message);
               }
               if (!result.data.user) {
                   throw new Error(`User '${username}' not found`);
               }
               return result.data.user.id;
            }

            async function fetchRepositories(username, useRestFallback = false) {
               if (useRestFallback) {
                   return await fetchRepositoriesRest(username);
               }
               updateProgress(20, 'Fetching repositories...');
               const ownedRepos = [];
               const contributedRepos = [];
               // Fetch owned repos
               let hasOwnerNextPage = true;
               let ownerAfterCursor = null;
               while (hasOwnerNextPage && ownedRepos.length < 100) {
                   const ownerQuery = `
                       query($login: String!, $after: String, $first: Int) {
                           user(login: $login) {
                               repositories(
                                   first: $first,
                                   after: $after,
                                   orderBy: {field: NAME, direction: ASC},
                                   ownerAffiliations: OWNER
                               ) {
                                   pageInfo { hasNextPage endCursor }
                                   nodes {
                                       id
                                       name
                                       url
                                       owner {
                                           login
                                       }
                                       defaultBranchRef {
                                           name
                                       }
                                   }
                               }
                           }
                       }
                   `;
                   const ownerResponse = await fetch(GRAPHQL_URL, {
                       method: 'POST',
                       headers: HEADERS,
                       body: JSON.stringify({
                           query: ownerQuery,
                           variables: {
                               login: username,
                               after: ownerAfterCursor,
                               first: Math.min(100, 100 - ownedRepos.length)
                           }
                       })
                   });
                   if (!ownerResponse.ok) {
                       throw new Error(`HTTP error! status: ${ownerResponse.status}`);
                   }
                   const ownerResult = await ownerResponse.json();
                   if (ownerResult.errors) {
                       throw new Error(ownerResult.errors[0].message);
                   }
                   const ownerData = ownerResult.data.user.repositories;
                   ownedRepos.push(...ownerData.nodes);
                   hasOwnerNextPage = ownerData.pageInfo.hasNextPage;
                   ownerAfterCursor = ownerData.pageInfo.endCursor;
               }
               // Fetch contributed repos
               let hasContribNextPage = true;
               let contribAfterCursor = null;
               while (hasContribNextPage && contributedRepos.length < 100) {
                   const contribQuery = `
                       query($login: String!, $after: String, $first: Int) {
                           user(login: $login) {
                               repositoriesContributedTo(
                                   first: $first,
                                   after: $after,
                                   orderBy: {field: NAME, direction: ASC},
                                   contributionTypes: [COMMIT, PULL_REQUEST, REPOSITORY],
                                   includeUserRepositories: false
                               ) {
                                   pageInfo { hasNextPage endCursor }
                                   nodes {
                                       id
                                       name
                                       url
                                       owner {
                                           login
                                       }
                                       defaultBranchRef {
                                           name
                                       }
                                   }
                               }
                           }
                       }
                   `;
                   const contribResponse = await fetch(GRAPHQL_URL, {
                       method: 'POST',
                       headers: HEADERS,
                       body: JSON.stringify({
                           query: contribQuery,
                           variables: {
                               login: username,
                               after: contribAfterCursor,
                               first: Math.min(100, 100 - contributedRepos.length)
                           }
                       })
                   });
                   if (!contribResponse.ok) {
                       throw new Error(`HTTP error! status: ${contribResponse.status}`);
                   }
                   const contribResult = await contribResponse.json();
                   if (contribResult.errors) {
                       throw new Error(contribResult.errors[0].message);
                   }
                   const contribData = contribResult.data.user.repositoriesContributedTo;
                   contributedRepos.push(...contribData.nodes);
                   hasContribNextPage = contribData.pageInfo.hasNextPage;
                   contribAfterCursor = contribData.pageInfo.endCursor;
               }
               // Remove duplicates (repos that are both owned and contributed to)
               const ownedIds = new Set(ownedRepos.map(repo => repo.id));
               const uniqueContributedRepos = contributedRepos.filter(repo => !ownedIds.has(repo.id));
               return {
                   ownedRepos: ownedRepos.slice(0, 100),
                   contributedRepos: uniqueContributedRepos.slice(0, 100)
               };
            }

            async function fetchCommitsForAllReposConcurrent(repos, userId, username, useRestFallback = false) {
               if (useRestFallback) {
                   return await fetchCommitsForAllReposConcurrentRest(repos, userId, username);
               }
               updateProgress(30, 'Fetching commit history...');
               // Process repos with valid default branches
               const validRepos = repos.filter(repo => repo.defaultBranchRef);
               // Create an array of promises for all repo commit fetches
               const commitPromises = validRepos.map(repo =>
                   fetchRepoCommits(repo.owner.login, repo.name, userId, username)
                       .then(repoCommits => ({
                           owner: repo.owner.login,
                           name: repo.name,
                           url: repo.url,
                           branch: repo.defaultBranchRef.name,
                           commit_count: repoCommits.length,
                           commits: repoCommits
                       }))
                       .catch(error => {
                           console.error(`Error fetching commits for ${repo.owner.login}/${repo.name}:`, error);
                           return null;
                       })
               );
               // Process all promises concurrently with progress updates
               const totalRepos = commitPromises.length;
               const results = [];
               // Process in batches to show progress - increased batch size for faster processing
               const batchSize = 10;
               for (let i = 0; i < commitPromises.length; i += batchSize) {
                   const batch = commitPromises.slice(i, i + batchSize);
                   const batchResults = await Promise.all(batch);
                   results.push(...batchResults.filter(result => result !== null));
                   // Update progress (30% to 90% range)
                   const progress = 30 + ((i + batchSize) / totalRepos) * 60;
                   updateProgress(Math.min(progress, 90), `Processed ${Math.min(i + batchSize, totalRepos)} of ${totalRepos} repositories...`);
               }
               return results.filter(result => result !== null);
            }

            async function fetchRepoCommits(owner, name, userId, username) {
                const repoCommits = [];
                let hasCommitsNextPage = true;
                let commitsEndCursor = null;
                // Fetch commits with author filter to get only user commits
                let iterations = 0;
                const maxIterations = 10; // Increased iterations for more commits
                while (hasCommitsNextPage && repoCommits.length < 1000 && iterations < maxIterations) {
                    const first = Math.min(100, 1000 - repoCommits.length);
                    let historyArgs = `first: ${first}`;
                    if (commitsEndCursor) {
                        historyArgs += `, after: "${commitsEndCursor}"`;
                    }
                    // Add author filter to get only commits by the user
                    historyArgs += `, author: {id: "${userId}"}`;
                    const query = `
                        query {
                            repository(owner: "${owner}", name: "${name}") {
                                url
                                defaultBranchRef {
                                    name
                                    target {
                                        ... on Commit {
                                            history(${historyArgs}) {
                                                pageInfo {
                                                    hasNextPage
                                                    endCursor
                                                }
                                                edges {
                                                    node {
                                                        message
                                                        committedDate
                                                        author {
                                                            user {
                                                                login
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    `;
                    const response = await fetch(GRAPHQL_URL, {
                        method: 'POST',
                        headers: HEADERS,
                        body: JSON.stringify({ query: query })
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.errors) {
                        throw new Error(result.errors[0].message);
                    }
                    const data = result.data.repository;
                    if (!data || !data.defaultBranchRef || !data.defaultBranchRef.target) {
                        break;
                    }
                    const history = data.defaultBranchRef.target.history;
                    const edges = history.edges;
                    // Map commits
                    const newCommits = edges
                        .map(edge => ({
                            message: edge.node.message,
                            date: edge.node.committedDate,
                            author: edge.node.author?.user?.login || 'Unknown'
                        }));
                    repoCommits.push(...newCommits);
                    hasCommitsNextPage = history.pageInfo.hasNextPage;
                    commitsEndCursor = history.pageInfo.endCursor;
                    iterations++;
                }
                return repoCommits;
            }

            // --- CHANGED: Modified displayResults to conditionally show "Show Everything" button ---
            function displayResults(username, stats, commitsData) {
                 // Update stats
                document.getElementById('commit-count').textContent = stats.totalCommits.toLocaleString();
                document.getElementById('owned-repo-count').textContent = stats.ownedRepos;
                document.getElementById('contributed-repo-count').textContent = stats.contributedRepos;
                // Display repository analysis
                const repoAnalysis = document.getElementById('repo-analysis');
                repoAnalysis.innerHTML = '<h2 style="color: #4ecdc4; margin-bottom: 20px;">Repository Analysis</h2>';
                if (commitsData.length === 0) {
                    repoAnalysis.innerHTML += '<p>No commit data available for analysis.</p>';
                    return;
                }
                // Store the full data on the element for later use
                repoAnalysis.dataset.allReposData = JSON.stringify(commitsData);
                // Show top repositories by commit count (initial view)
                displayTopRepos(commitsData, repoAnalysis);
                // --- CHANGED: Only create and append the "Show Everything" button if needed ---
                // Check if we have more repos than the 5 we are showing
                if (commitsData.length > 5) {
                    // Create and append the "Show Everything" button
                    const showAllButton = document.createElement('button');
                    showAllButton.id = 'show-all-btn';
                    showAllButton.className = 'modal-btn primary-btn';
                    showAllButton.textContent = 'Show Everything';
                    showAllButton.style.display = 'block'; // Initially visible
                    showAllButton.style.margin = '20px auto 0 auto'; // Center it
                    showAllButton.style.width = 'fit-content';
                    // Store visibility state for toggle button interaction
                    showAllButton.dataset.wasVisible = 'true';
                    showAllButton.addEventListener('click', function() {
                        displayAllRepos(commitsData, repoAnalysis);
                        showAllButton.style.display = 'none'; // Hide button after clicking
                        showAllButton.dataset.wasVisible = 'false'; // Update state
                    });
                    repoAnalysis.appendChild(showAllButton);
                    // Store reference to the button for hiding/showing with toggle
                    repoAnalysis.dataset.showAllButtonId = showAllButton.id;
                }
                // --- END OF CHANGED ---
            }
            // Function to display only the top 5 repos
            function displayTopRepos(commitsData, containerElement) {
                // Clear existing repo sections but keep the main title
                const title = containerElement.querySelector('h2');
                const showAllBtn = document.getElementById(containerElement.dataset.showAllButtonId);
                containerElement.innerHTML = ''; // Clear
                if (title) containerElement.appendChild(title); // Re-add title
                // Show top repositories by commit count
                const sortedRepos = [...commitsData].sort((a, b) => b.commit_count - a.commit_count);
                const topRepos = sortedRepos.slice(0, 5);
                if (topRepos.length === 0) {
                    containerElement.innerHTML += '<p>No commits found for analysis.</p>';
                    return;
                }
                topRepos.forEach(repo => {
                    const repoDiv = document.createElement('div');
                    repoDiv.className = 'repo-section';
                    // Handle potential errors from REST fallback
                    const errorMessage = repo.error ? `<div style="color: #ff6b6b; font-size: 0.8rem; margin-top: 5px;">Note: ${repo.error}</div>` : '';
                    repoDiv.innerHTML = `
                        <div class="repo-title">
                            <a href="${repo.url}" class="repo-url" target="_blank">${repo.owner}/${repo.name}</a>
                            <span>${repo.commit_count} commits</span>
                        </div>
                        <div class="commit-list">
                            ${repo.commits.slice(0, 3).map(commit => `
                                <div class="commit-item">
                                    <div class="commit-message">${(commit.message.length > 150 ? commit.message.substring(0, 150) + '...' : commit.message)}</div>
                                    <div class="commit-date">${new Date(commit.date).toLocaleDateString()}</div>
                                </div>
                            `).join('')}
                            ${repo.commits.length > 3 ? `<div class="commit-item">... and ${repo.commits.length - 3} more commits</div>` : ''}
                        </div>
                        ${errorMessage}
                    `;
                    containerElement.appendChild(repoDiv);
                });
                // --- CHANGED: Re-append the "Show Everything" button if it existed and was meant to be visible ---
                if (showAllBtn) {
                    // Only show if it was previously set to display 'block' or if we just created it
                    if (showAllBtn.dataset.wasVisible === 'true') {
                         showAllBtn.style.display = 'block'; // Make sure it's visible
                    }
                    containerElement.appendChild(showAllBtn);
                }
                // --- END OF CHANGED ---
            }
            // Function to display all repos
            function displayAllRepos(commitsData, containerElement) {
                // Clear existing repo sections but keep the main title
                const title = containerElement.querySelector('h2');
                containerElement.innerHTML = ''; // Clear
                if (title) containerElement.appendChild(title); // Re-add title
                // Show ALL repositories by commit count
                const sortedRepos = [...commitsData].sort((a, b) => b.commit_count - a.commit_count);
                if (sortedRepos.length === 0) {
                    containerElement.innerHTML += '<p>No commits found for analysis.</p>';
                    return;
                }
                sortedRepos.forEach(repo => {
                    const repoDiv = document.createElement('div');
                    repoDiv.className = 'repo-section';
                    // Handle potential errors from REST fallback
                    const errorMessage = repo.error ? `<div style="color: #ff6b6b; font-size: 0.8rem; margin-top: 5px;">Note: ${repo.error}</div>` : '';
                    repoDiv.innerHTML = `
                        <div class="repo-title">
                            <a href="${repo.url}" class="repo-url" target="_blank">${repo.owner}/${repo.name}</a>
                            <span>${repo.commit_count} commits</span>
                        </div>
                        <div class="commit-list">
                            ${repo.commits.slice(0, 3).map(commit => `
                                <div class="commit-item">
                                    <div class="commit-message">${(commit.message.length > 150 ? commit.message.substring(0, 150) + '...' : commit.message)}</div>
                                    <div class="commit-date">${new Date(commit.date).toLocaleDateString()}</div>
                                </div>
                            `).join('')}
                            ${repo.commits.length > 3 ? `<div class="commit-item">... and ${repo.commits.length - 3} more commits</div>` : ''}
                        </div>
                        ${errorMessage}
                    `;
                    containerElement.appendChild(repoDiv);
                });
                 // Note: The "Show Everything" button is hidden by its own click handler
            }

            // --- MODIFIED: analyzeUser to accept and use useRestFallback flag ---
            async function analyzeUser(username, useRestFallback = false) {
                try {
                    // Step 1: Get user ID
                    const userId = await getUserId(username, useRestFallback);
                    // Step 2: Fetch repositories
                    const { ownedRepos, contributedRepos } = await fetchRepositories(username, useRestFallback);
                    // Step 3: Fetch commits concurrently
                    const commitsData = await fetchCommitsForAllReposConcurrent(
                        ownedRepos.concat(contributedRepos),
                        userId,
                        username,
                        useRestFallback // Pass the flag down
                    );
                    // Step 4: Calculate stats
                    updateProgress(95, useRestFallback ? 'Generating analysis (REST)...' : 'Generating analysis...');
                    const totalCommits = commitsData.reduce((sum, repo) => sum + (repo.commit_count || 0), 0);
                    const stats = {
                        totalCommits: totalCommits,
                        ownedRepos: ownedRepos.length,
                        contributedRepos: contributedRepos.length
                    };
                    // Step 5: Display results
                    updateProgress(100, useRestFallback ? 'Analysis complete (REST)!' : 'Analysis complete!');
                    displayResults(username, stats, commitsData);
                } catch (error) {
                    throw new Error(`Failed to analyze user: ${error.message}`);
                }
            }
            // --- END OF MODIFIED: analyzeUser ---

        });
    </script>
</body>
</html>
```